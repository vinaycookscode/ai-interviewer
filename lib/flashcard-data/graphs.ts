// Graphs - 25 Detailed Flashcards
export const GRAPHS_CARDS = [
    { front: "What is the difference between BFS and DFS for graph traversal?", back: "**BFS (Breadth-First Search):**\n- Uses **queue** (FIFO)\n- Explores level by level\n- **Use for:** Shortest path (unweighted), level-order\n- Space: O(V) for queue\n\n**DFS (Depth-First Search):**\n- Uses **stack** or recursion\n- Explores as deep as possible first\n- **Use for:** Cycle detection, topological sort, connected components\n- Space: O(V) for recursion stack\n\n**Both: O(V + E) time with adjacency list**" },
    { front: "How do you detect a cycle in an undirected graph?", back: "**DFS with Parent Tracking:**\n\n```python\ndef hasCycle(graph, n):\n    visited = [False] * n\n    \n    def dfs(node, parent):\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, node): return True\n            elif neighbor != parent:  # Back edge, not parent\n                return True\n        return False\n    \n    for i in range(n):\n        if not visited[i] and dfs(i, -1):\n            return True\n    return False\n```\n\n**Key:** If we reach a visited node that isn't our parent → cycle exists" },
    { front: "How do you detect a cycle in a directed graph?", back: "**DFS with 3 Colors (White, Gray, Black):**\n\n```python\ndef hasCycle(graph, n):\n    WHITE, GRAY, BLACK = 0, 1, 2\n    color = [WHITE] * n\n    \n    def dfs(node):\n        color[node] = GRAY  # Visiting\n        for neighbor in graph[node]:\n            if color[neighbor] == GRAY:  # Back edge!\n                return True\n            if color[neighbor] == WHITE and dfs(neighbor):\n                return True\n        color[node] = BLACK  # Done\n        return False\n    \n    for i in range(n):\n        if color[i] == WHITE and dfs(i):\n            return True\n    return False\n```\n\n**Gray → Gray = cycle (back edge to ancestor)**" },
    { front: "Explain Topological Sort and how to implement it.", back: "**Topological Sort:** Linear ordering of vertices in DAG such that for every edge (u,v), u comes before v.\n\n**Kahn's Algorithm (BFS):**\n```python\ndef topologicalSort(graph, n):\n    in_degree = [0] * n\n    for u in range(n):\n        for v in graph[u]:\n            in_degree[v] += 1\n    \n    queue = [i for i in range(n) if in_degree[i] == 0]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result if len(result) == n else []  # Empty if cycle\n```\n\n**Use cases:** Build order, course scheduling, task dependencies" },
    { front: "Explain Dijkstra's Algorithm for shortest path.", back: "**Dijkstra's:** Shortest path from source to all vertices (non-negative weights)\n\n```python\nimport heapq\n\ndef dijkstra(graph, start, n):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    pq = [(0, start)]  # (distance, node)\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist[u]: continue  # Skip outdated\n        \n        for v, weight in graph[u]:\n            if dist[u] + weight < dist[v]:\n                dist[v] = dist[u] + weight\n                heapq.heappush(pq, (dist[v], v))\n    \n    return dist\n```\n\n**Complexity:** O((V + E) log V) with binary heap\n\n**Limitation:** Doesn't work with negative edges!" },
    { front: "When would you use Bellman-Ford over Dijkstra?", back: "**Use Bellman-Ford when:**\n1. Graph has **negative weight edges**\n2. Need to **detect negative cycles**\n\n```python\ndef bellmanFord(edges, n, start):\n    dist = [float('inf')] * n\n    dist[start] = 0\n    \n    # Relax all edges V-1 times\n    for _ in range(n - 1):\n        for u, v, w in edges:\n            if dist[u] != float('inf') and dist[u] + w < dist[v]:\n                dist[v] = dist[u] + w\n    \n    # Check for negative cycle\n    for u, v, w in edges:\n        if dist[u] != float('inf') and dist[u] + w < dist[v]:\n            return None  # Negative cycle exists\n    \n    return dist\n```\n\n**Complexity:** O(V × E) - slower than Dijkstra" },
    { front: "How does Union-Find (Disjoint Set Union) work?", back: "**Union-Find:** Data structure for tracking disjoint sets\n\n```python\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n))\n        self.rank = [0] * n\n    \n    def find(self, x):  # Path compression\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):  # Union by rank\n        px, py = self.find(x), self.find(y)\n        if px == py: return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n```\n\n**Complexity:** Nearly O(1) amortized (inverse Ackermann)\n\n**Uses:** Kruskal's MST, cycle detection, connected components" },
    { front: "How do you solve the Number of Islands problem?", back: "**Problem:** Count connected components of '1's in grid.\n\n```python\ndef numIslands(grid):\n    if not grid: return 0\n    m, n = len(grid), len(grid[0])\n    count = 0\n    \n    def dfs(i, j):\n        if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] != '1':\n            return\n        grid[i][j] = '0'  # Mark visited\n        dfs(i+1, j)\n        dfs(i-1, j)\n        dfs(i, j+1)\n        dfs(i, j-1)\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == '1':\n                count += 1\n                dfs(i, j)\n    \n    return count\n```\n\n**Alternatives:** BFS, Union-Find\n**Complexity:** O(m × n)" },
    { front: "How do you solve the Clone Graph problem?", back: "**DFS with HashMap:**\n\n```python\ndef cloneGraph(node):\n    if not node: return None\n    \n    cloned = {}  # original → clone mapping\n    \n    def dfs(node):\n        if node in cloned:\n            return cloned[node]\n        \n        clone = Node(node.val)\n        cloned[node] = clone\n        \n        for neighbor in node.neighbors:\n            clone.neighbors.append(dfs(neighbor))\n        \n        return clone\n    \n    return dfs(node)\n```\n\n**Key Points:**\n- HashMap prevents infinite loops on cycles\n- Create clone before recursing to handle back edges\n- O(V + E) time and space" },
    { front: "How do you solve Course Schedule (can finish all courses)?", back: "**Cycle detection in directed graph using topological sort:**\n\n```python\ndef canFinish(numCourses, prerequisites):\n    graph = [[] for _ in range(numCourses)]\n    in_degree = [0] * numCourses\n    \n    for course, prereq in prerequisites:\n        graph[prereq].append(course)\n        in_degree[course] += 1\n    \n    queue = [i for i in range(numCourses) if in_degree[i] == 0]\n    count = 0\n    \n    while queue:\n        node = queue.pop(0)\n        count += 1\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return count == numCourses  # All courses processed = no cycle\n```" },
    { front: "How do you solve the Word Ladder problem (shortest transformation)?", back: "**BFS for shortest path in unweighted graph:**\n\n```python\ndef ladderLength(beginWord, endWord, wordList):\n    wordSet = set(wordList)\n    if endWord not in wordSet: return 0\n    \n    queue = [(beginWord, 1)]\n    visited = {beginWord}\n    \n    while queue:\n        word, length = queue.pop(0)\n        if word == endWord:\n            return length\n        \n        for i in range(len(word)):\n            for c in 'abcdefghijklmnopqrstuvwxyz':\n                newWord = word[:i] + c + word[i+1:]\n                if newWord in wordSet and newWord not in visited:\n                    visited.add(newWord)\n                    queue.append((newWord, length + 1))\n    \n    return 0\n```\n\n**Optimization:** Bidirectional BFS for faster convergence" },
    { front: "How do you check if a graph is bipartite?", back: "**Two-Coloring with BFS/DFS:**\n\n```python\ndef isBipartite(graph):\n    n = len(graph)\n    color = [-1] * n  # -1 = uncolored\n    \n    for start in range(n):\n        if color[start] != -1: continue\n        \n        queue = [start]\n        color[start] = 0\n        \n        while queue:\n            node = queue.pop(0)\n            for neighbor in graph[node]:\n                if color[neighbor] == -1:\n                    color[neighbor] = 1 - color[node]  # Opposite color\n                    queue.append(neighbor)\n                elif color[neighbor] == color[node]:\n                    return False  # Same color = not bipartite\n    \n    return True\n```\n\n**Bipartite:** Graph can be split into two sets with edges only between sets." },
    { front: "How do you find the shortest path in a weighted graph using Dijkstra?", back: "**Network Delay Time (Dijkstra application):**\n\n```python\ndef networkDelayTime(times, n, k):\n    graph = defaultdict(list)\n    for u, v, w in times:\n        graph[u].append((v, w))\n    \n    dist = {k: 0}\n    pq = [(0, k)]\n    \n    while pq:\n        d, u = heapq.heappop(pq)\n        if d > dist.get(u, float('inf')): continue\n        \n        for v, w in graph[u]:\n            if d + w < dist.get(v, float('inf')):\n                dist[v] = d + w\n                heapq.heappush(pq, (d + w, v))\n    \n    return max(dist.values()) if len(dist) == n else -1\n```\n\n**Answer:** Maximum of all shortest paths = time for signal to reach all nodes" },
    { front: "What is Prim's Algorithm for Minimum Spanning Tree?", back: "**Prim's Algorithm:** Grow MST by adding minimum edge to tree.\n\n```python\ndef primMST(graph, n):\n    visited = [False] * n\n    pq = [(0, 0)]  # (weight, node)\n    mst_weight = 0\n    edges_added = 0\n    \n    while pq and edges_added < n:\n        weight, u = heapq.heappop(pq)\n        if visited[u]: continue\n        \n        visited[u] = True\n        mst_weight += weight\n        edges_added += 1\n        \n        for v, w in graph[u]:\n            if not visited[v]:\n                heapq.heappush(pq, (w, v))\n    \n    return mst_weight if edges_added == n else -1\n```\n\n**Complexity:** O(E log V) with binary heap\n**vs Kruskal's:** Prim's better for dense graphs, Kruskal's for sparse" },
    { front: "What is Kruskal's Algorithm for Minimum Spanning Tree?", back: "**Kruskal's Algorithm:** Sort edges, add if doesn't create cycle (Union-Find).\n\n```python\ndef kruskalMST(edges, n):\n    edges.sort(key=lambda x: x[2])  # Sort by weight\n    uf = UnionFind(n)\n    mst_weight = 0\n    edges_added = 0\n    \n    for u, v, w in edges:\n        if uf.union(u, v):  # No cycle\n            mst_weight += w\n            edges_added += 1\n            if edges_added == n - 1:\n                break\n    \n    return mst_weight if edges_added == n - 1 else -1\n```\n\n**Complexity:** O(E log E) for sorting\n**MST properties:** V-1 edges, minimum total weight, connects all vertices" },
    { front: "How do you find all Strongly Connected Components (SCCs)?", back: "**Kosaraju's Algorithm:**\n\n```python\ndef findSCCs(graph, n):\n    # Step 1: DFS to get finish order\n    visited = [False] * n\n    stack = []\n    \n    def dfs1(u):\n        visited[u] = True\n        for v in graph[u]:\n            if not visited[v]: dfs1(v)\n        stack.append(u)\n    \n    for i in range(n):\n        if not visited[i]: dfs1(i)\n    \n    # Step 2: Build reverse graph\n    reverse = [[] for _ in range(n)]\n    for u in range(n):\n        for v in graph[u]:\n            reverse[v].append(u)\n    \n    # Step 3: DFS in reverse order on reversed graph\n    visited = [False] * n\n    sccs = []\n    \n    def dfs2(u, component):\n        visited[u] = True\n        component.append(u)\n        for v in reverse[u]:\n            if not visited[v]: dfs2(v, component)\n    \n    while stack:\n        u = stack.pop()\n        if not visited[u]:\n            component = []\n            dfs2(u, component)\n            sccs.append(component)\n    \n    return sccs\n```" },
    { front: "How do you find the shortest path in a matrix with 0s and 1s?", back: "**BFS for Shortest Path in Binary Matrix:**\n\n```python\ndef shortestPathBinaryMatrix(grid):\n    n = len(grid)\n    if grid[0][0] or grid[n-1][n-1]: return -1\n    \n    directions = [(-1,-1),(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0),(1,1)]\n    queue = [(0, 0, 1)]  # (row, col, distance)\n    grid[0][0] = 1  # Mark visited\n    \n    while queue:\n        r, c, dist = queue.pop(0)\n        if r == n-1 and c == n-1:\n            return dist\n        \n        for dr, dc in directions:\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == 0:\n                grid[nr][nc] = 1\n                queue.append((nr, nc, dist + 1))\n    \n    return -1\n```\n\n**8 directions allowed, find path from (0,0) to (n-1,n-1)**" },
    { front: "How do you solve the Rotting Oranges problem?", back: "**Multi-source BFS:**\n\n```python\ndef orangesRotting(grid):\n    m, n = len(grid), len(grid[0])\n    queue = []\n    fresh = 0\n    \n    for i in range(m):\n        for j in range(n):\n            if grid[i][j] == 2:\n                queue.append((i, j))\n            elif grid[i][j] == 1:\n                fresh += 1\n    \n    if fresh == 0: return 0\n    \n    minutes = 0\n    directions = [(0,1),(0,-1),(1,0),(-1,0)]\n    \n    while queue:\n        minutes += 1\n        for _ in range(len(queue)):\n            r, c = queue.pop(0)\n            for dr, dc in directions:\n                nr, nc = r + dr, c + dc\n                if 0 <= nr < m and 0 <= nc < n and grid[nr][nc] == 1:\n                    grid[nr][nc] = 2\n                    fresh -= 1\n                    queue.append((nr, nc))\n    \n    return minutes - 1 if fresh == 0 else -1\n```" },
    { front: "What is the Floyd-Warshall Algorithm?", back: "**Floyd-Warshall:** All-pairs shortest path in O(V³)\n\n```python\ndef floydWarshall(graph, n):\n    dist = [[float('inf')] * n for _ in range(n)]\n    \n    # Initialize\n    for i in range(n):\n        dist[i][i] = 0\n        for j, w in graph[i]:\n            dist[i][j] = w\n    \n    # DP: consider each vertex as intermediate\n    for k in range(n):\n        for i in range(n):\n            for j in range(n):\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n    \n    return dist\n```\n\n**Use cases:**\n- Small graphs (V < 1000)\n- Need all-pairs shortest paths\n- Can handle negative edges (no negative cycles)\n- Detect negative cycles: dist[i][i] < 0" },
    { front: "How do you find Critical Connections in a Network (Bridges)?", back: "**Tarjan's Algorithm for Bridges:**\n\n```python\ndef criticalConnections(n, connections):\n    graph = defaultdict(list)\n    for u, v in connections:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    disc = [-1] * n  # Discovery time\n    low = [-1] * n   # Lowest reachable\n    bridges = []\n    time = [0]\n    \n    def dfs(u, parent):\n        disc[u] = low[u] = time[0]\n        time[0] += 1\n        \n        for v in graph[u]:\n            if disc[v] == -1:  # Not visited\n                dfs(v, u)\n                low[u] = min(low[u], low[v])\n                if low[v] > disc[u]:  # Bridge!\n                    bridges.append([u, v])\n            elif v != parent:\n                low[u] = min(low[u], disc[v])\n    \n    dfs(0, -1)\n    return bridges\n```\n\n**Bridge:** Edge whose removal disconnects graph\n**Condition:** low[v] > disc[u] means no back edge from v's subtree to u's ancestors" },
];
