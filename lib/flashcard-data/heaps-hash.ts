// Heaps & Priority Queues + Hash Tables - 100 Flashcards
export const HEAPS_HASH_CARDS = [
    // Heaps (50)
    { front: "Heap insert complexity?", back: "O(log n). Add at end, bubble up." },
    { front: "Heap extract min/max?", back: "O(log n). Swap with last, remove, bubble down." },
    { front: "Heap peek?", back: "O(1). Return root without removing." },
    { front: "Build heap from array?", back: "O(n). Heapify from bottom up." },
    { front: "Min heap vs Max heap?", back: "Min: smallest at root. Max: largest at root." },
    { front: "Heapify operation?", back: "Restore heap property at node. Compare with children, swap if needed." },
    { front: "Kth largest element", back: "Min heap of size k. Top is Kth largest. O(n log k)." },
    { front: "Kth smallest element", back: "Max heap of size k, or min heap with n-k elements." },
    { front: "Merge K sorted lists", back: "Min heap with one from each. Pop min, push next. O(n log k)." },
    { front: "Merge K sorted arrays", back: "Same as lists. Heap of (value, array_idx, elem_idx)." },
    { front: "Find median in stream", back: "Two heaps: max for lower, min for upper. Balance sizes." },
    { front: "Sliding window median", back: "Two heaps with lazy deletion. Or balance BST." },
    { front: "Top K frequent elements", back: "Count frequencies, heap of size k. O(n log k)." },
    { front: "K closest points to origin", back: "Max heap of size k by distance. O(n log k)." },
    { front: "K closest elements to target", back: "Max heap by distance to target. Or binary search + two pointers." },
    { front: "Sort nearly sorted array (k elements away)", back: "Min heap of size k+1. O(n log k)." },
    { front: "Smallest range covering elements from K lists", back: "Heap with pointers. Track max. Minimize range." },
    { front: "Reorganize string", back: "Max heap by frequency. Alternate placing chars." },
    { front: "Task scheduler with heap", back: "Max heap for frequencies. Process, cooldown queue." },
    { front: "Process tasks by priority", back: "Priority queue. Pop highest priority first." },
    { front: "Meeting Rooms II (heap)", back: "Sort by start, min heap for end times. O(n log n)." },
    { front: "Minimum cost to connect sticks", back: "Always combine smallest two. Min heap. O(n log n)." },
    { front: "Last Stone Weight", back: "Max heap. Smash largest two. O(n log n)." },
    { front: "Kth Smallest in Matrix", back: "Min heap with (value, row, col). Or binary search." },
    { front: "Kth Smallest Prime Fraction", back: "Heap or binary search on answer." },
    { front: "IPO (Maximize capital)", back: "Two heaps: projects by capital and profit." },
    { front: "Find K pairs with smallest sums", back: "Min heap with (sum, i, j). Expand carefully." },
    { front: "Ugly Number II", back: "Min heap with factors 2, 3, 5. Or DP with pointers." },
    { front: "Super Ugly Number", back: "Generalize with k primes. Heap or pointers." },
    { front: "Course Schedule III", back: "Sort by deadline, max heap for durations. Greedy swap." },
    { front: "Trapping Rain Water II", back: "Min heap BFS from boundary. O(mn log mn)." },
    { front: "Dijkstra with priority queue", back: "Min heap of (distance, node). O((V+E) log V)." },
    { front: "Prim's MST with heap", back: "Min heap of (weight, edge). O(E log V)." },
    { front: "Cheapest Flights K Stops (heap)", back: "Modified Dijkstra with (cost, node, stops)." },
    { front: "Network Delay Time", back: "Dijkstra. Answer is max of distances." },
    { front: "Path with Maximum Probability", back: "Modified Dijkstra with max heap and products." },
    { front: "Swim in Rising Water", back: "Min heap Dijkstra variant." },
    { front: "Path with Minimum Effort", back: "Binary search + BFS, or Dijkstra with max effort." },
    { front: "Maximum Performance of Team", back: "Sort by efficiency, max heap for speeds." },
    { front: "Single-Threaded CPU", back: "Two heaps: available and by start time." },
    { front: "Maximum Average Pass Ratio", back: "Max heap by marginal gain. Greedy assignment." },
    { front: "Minimum Number of Refueling Stops", back: "Max heap of passed stations. Greedy refuel." },
    { front: "Employee Free Time", back: "Merge intervals with heap. Find gaps." },
    { front: "Find Subsequence of Length K With Largest Sum", back: "Heap to find K largest, maintain order." },
    { front: "Furthest Building You Can Reach", back: "Min heap for ladder use. Greedy assignment." },
    { front: "The Number of the Smallest Unoccupied Chair", back: "Two heaps: leaving times and available chairs." },
    { front: "Maximum Number of Events", back: "Sort by end day, greedy with heap." },
    { front: "Minimum Interval to Include Each Query", back: "Sort intervals and queries. Min heap by size." },
    { front: "Avoid Flood in The City", back: "HashMap + ordered set for dry days." },
    { front: "Seat Reservation Manager", back: "Min heap of available seats." },
    // Hash Tables (50)
    { front: "Hash table average time complexity?", back: "O(1) for insert, delete, search. Worst O(n)." },
    { front: "Hash collision handling: chaining?", back: "Linked list at each bucket. Simple but extra memory." },
    { front: "Hash collision handling: open addressing?", back: "Probe for next empty slot. Linear, quadratic, or double hashing." },
    { front: "Load factor in hash table?", back: "n/capacity. Resize when > 0.75 typically." },
    { front: "Two Sum", back: "HashMap: store complements. O(n) time, O(n) space." },
    { front: "Four Sum II", back: "Two HashMaps: sums of pairs from A+B and C+D." },
    { front: "Group Anagrams", back: "Sorted string as key, or frequency count as key." },
    { front: "Valid Anagram", back: "Character count comparison. O(n) time." },
    { front: "First unique character", back: "Count frequencies, find first with count 1." },
    { front: "Happy Number", back: "HashSet to detect cycle. Or slow/fast pointers." },
    { front: "Contains Duplicate", back: "HashSet. O(n) time, O(n) space." },
    { front: "Contains Duplicate II", back: "HashSet with sliding window of size k." },
    { front: "Contains Duplicate III", back: "Buckets of size t+1, or balanced BST." },
    { front: "Longest Consecutive Sequence", back: "HashSet. For each start of sequence, count length. O(n)." },
    { front: "Missing Number", back: "Sum formula or XOR. HashSet also works." },
    { front: "Single Number", back: "XOR all. Pairs cancel, single remains." },
    { front: "Single Number II (thrice)", back: "Bit counting mod 3. Or general formula." },
    { front: "Single Number III (two singles)", back: "XOR all gets a^b. Split by differing bit." },
    { front: "Subarray Sum Equals K", back: "Prefix sum + HashMap counting occurrences." },
    { front: "Continuous Subarray Sum", back: "Prefix sum mod k. Same remainder = valid subarray." },
    { front: "Subarray Sums Divisible by K", back: "Same as above. Count same remainders." },
    { front: "Find All Anagrams in String", back: "Sliding window with char count comparison." },
    { front: "Permutation in String", back: "Same as find anagrams. Window size = pattern length." },
    { front: "Longest Substring Without Repeat", back: "Sliding window with HashSet or HashMap of last indices." },
    { front: "Minimum Window Substring", back: "Sliding window with required char counts." },
    { front: "Isomorphic Strings", back: "Two HashMaps for bidirectional mapping." },
    { front: "Word Pattern", back: "Bijection between words and pattern chars." },
    { front: "Logger Rate Limiter", back: "HashMap of message to last timestamp." },
    { front: "Design HashMap", back: "Array of buckets (linked lists). Hash % size." },
    { front: "Design HashSet", back: "Same as HashMap but only store keys." },
    { front: "Design Twitter", back: "HashMap of tweets per user, follow lists. Merge feeds." },
    { front: "LRU Cache", back: "HashMap + Doubly Linked List for O(1) operations." },
    { front: "LFU Cache", back: "Multiple HashMaps: key to node, freq to list." },
    { front: "Insert Delete GetRandom O(1)", back: "HashMap + ArrayList. Swap with last for delete." },
    { front: "Insert Delete GetRandom Duplicates", back: "HashMap to set of indices. Same swap technique." },
    { front: "First Missing Positive", back: "Use array as hash table. Place n at index n-1." },
    { front: "Find Duplicate Number", back: "Cycle detection (Floyd's) treating indices as links." },
    { front: "Set Mismatch", back: "Math approach or use array as hash." },
    { front: "Number of Good Pairs", back: "Count occurrences. For each num, add count to result." },
    { front: "Pairs of Songs With Total Durations Divisible by 60", back: "Remainders mod 60. Pair with complement." },
    { front: "Count Number of Nice Subarrays", back: "Prefix sum of odd counts. HashMap for counts." },
    { front: "Brick Wall", back: "HashMap of gap positions. Find most common gap." },
    { front: "Max Points on a Line", back: "For each point, HashMap of slopes. O(nÂ²)." },
    { front: "Number of Boomerangs", back: "For each point, count distances. n*(n-1) for each distance." },
    { front: "Fraction to Recurring Decimal", back: "HashMap of remainders to detect cycle start." },
    { front: "Copy List with Random Pointer", back: "HashMap of old to new nodes. Two passes." },
    { front: "Clone Graph", back: "HashMap of cloned nodes. DFS/BFS cloning." },
    { front: "Encode and Decode TinyURL", back: "HashMap for bidirectional mapping. Random or counter ID." },
    { front: "Valid Sudoku", back: "HashSets for each row, col, and 3x3 box." },
    { front: "Sudoku Solver", back: "Backtracking with fast validity check using sets." },
];
