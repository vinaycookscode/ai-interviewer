// Linked Lists - 100 Flashcards
export const LINKED_LISTS_CARDS = [
    { front: "How to reverse a linked list?", back: "Use 3 pointers: prev, curr, next. Iterate and reverse links. O(n) time, O(1) space." },
    { front: "How to detect a cycle in linked list?", back: "Floyd's Cycle Detection: slow moves 1 step, fast moves 2. If they meet, cycle exists." },
    { front: "How to find middle of linked list?", back: "Fast-slow pointers: fast moves 2x speed. When fast reaches end, slow is at middle." },
    { front: "Merge two sorted linked lists", back: "Compare heads, attach smaller. Use dummy node for cleaner code. O(n+m) time." },
    { front: "Remove nth node from end", back: "Two pointers with n gap. When first reaches end, second is at target." },
    { front: "Check if linked list is palindrome", back: "Find middle, reverse second half, compare. O(n) time, O(1) space." },
    { front: "Find the starting node of cycle", back: "After detection, reset one pointer to head. Move both 1 step until they meet." },
    { front: "Remove duplicates from sorted list", back: "Compare current with next, skip if duplicate. O(n) time." },
    { front: "Remove duplicates from unsorted list", back: "Use HashSet to track seen values. O(n) time, O(n) space." },
    { front: "Add two numbers as linked lists", back: "Traverse both, add digits with carry. Create new nodes for result." },
    { front: "Intersection of two linked lists", back: "Calculate lengths, advance longer by difference, then traverse together." },
    { front: "Copy list with random pointer", back: "Interleave copies, set random pointers, separate lists. O(n) time, O(1) extra." },
    { front: "Flatten a multilevel doubly linked list", back: "DFS/stack approach: when child exists, recurse down first." },
    { front: "Rotate list by k positions", back: "Find length, connect tail to head (cycle), break at new head." },
    { front: "Partition list around value x", back: "Create two lists: less than x, greater or equal. Concatenate." },
    { front: "Swap nodes in pairs", back: "Recursively swap pairs, or iteratively with dummy node." },
    { front: "Reverse nodes in k-groups", back: "Reverse each group of k, connect groups. Handle remainder." },
    { front: "Sort linked list", back: "Merge sort: find middle, sort halves, merge. O(n log n) time." },
    { front: "Insertion sort on linked list", back: "Build sorted list by inserting each node at correct position." },
    { front: "Reorder list (L0→Ln→L1→Ln-1...)", back: "Find middle, reverse second half, interleave both halves." },
    { front: "Delete node without head pointer", back: "Copy next node's value to current, delete next. Can't delete tail." },
    { front: "Merge k sorted lists", back: "Min-heap with one element from each list. O(n log k) time." },
    { front: "Split linked list into parts", back: "Calculate part sizes (n/k and remainder), split accordingly." },
    { front: "Design LRU Cache with linked list", back: "HashMap + Doubly Linked List. O(1) get/put. Move accessed to front." },
    { front: "Find kth node from end", back: "Two pointers with k gap. Or find length, then (n-k)th from start." },
    { front: "Singly vs Doubly linked list", back: "Singly: one direction, less memory. Doubly: both directions, easier deletion." },
    { front: "Check if two lists merge", back: "If tail nodes are same, lists merge somewhere. Find intersection point." },
    { front: "Insert in sorted linked list", back: "Find position where node.val > newVal, insert before. Handle head case." },
    { front: "Delete all nodes with value x", back: "Use dummy node, traverse and skip matching nodes." },
    { front: "Reverse between positions m and n", back: "Reach position m, reverse until n, reconnect ends." },
    { front: "Odd-even linked list", back: "Separate odd and even indexed nodes, concatenate odd list with even." },
    { front: "Plus one to linked list", back: "Reverse, add one with carry, reverse back. Or find rightmost non-9." },
    { front: "Convert sorted list to BST", back: "Find middle as root, recurse on left and right halves." },
    { front: "Linked list to binary tree", back: "Level order: use queue, create nodes left to right." },
    { front: "Binary tree to linked list (flatten)", back: "Preorder traversal, connect nodes in that order." },
    { front: "Circular linked list insertion", back: "Find position, handle empty list and single node cases." },
    { front: "Delete node in circular list", back: "Find previous node, update its next pointer." },
    { front: "Josephus problem with linked list", back: "Circular list, delete every kth node until one remains." },
    { front: "Polynomial addition with linked lists", back: "Each node: coefficient and exponent. Add like terms." },
    { front: "Polynomial multiplication", back: "Multiply each term, add to result list, combine like terms." },
    { front: "Skip list basics", back: "Multi-level linked list with skip pointers. O(log n) search average." },
    { front: "XOR linked list", back: "Each node stores XOR of prev and next. Saves space but complex." },
    { front: "Memory efficient doubly linked list", back: "XOR of addresses instead of two pointers. Trade complexity for space." },
    { front: "Unrolled linked list", back: "Each node contains array of elements. Better cache performance." },
    { front: "Self-organizing list (MTF)", back: "Move accessed element to front. Improves future access." },
    { front: "Self-organizing list (transpose)", back: "Swap accessed element with previous. Gradual improvement." },
    { front: "Find loop length in linked list", back: "After detecting cycle, count steps until same node again." },
    { front: "Remove loop from linked list", back: "Find loop start, traverse to find node pointing to start, set next=null." },
    { front: "Merge a linked list into another at alternate positions", back: "Interleave nodes from both lists." },
    { front: "Pairwise swap elements", back: "Swap adjacent pairs by changing links or values." },
    { front: "Clone a linked list with next and random", back: "Three passes: copy, set random via mapping, separate." },
    { front: "Subtract two numbers represented as linked lists", back: "Handle borrow, reverse if needed for proper subtraction." },
    { front: "Convert binary linked list to integer", back: "Traverse, multiply result by 2 and add digit value." },
    { front: "Decimal to binary as linked list", back: "Repeatedly divide by 2, insert remainders at head." },
    { front: "Length of linked list (iterative)", back: "Count nodes until null. O(n) time." },
    { front: "Length of linked list (recursive)", back: "return head == null ? 0 : 1 + length(head.next)" },
    { front: "Search element in linked list", back: "Traverse until found or end. O(n) time." },
    { front: "Get nth node value", back: "Traverse n steps from head. Check bounds." },
    { front: "Print linked list in reverse", back: "Recursion: print(node.next) then print(node). Or use stack." },
    { front: "Check if list length is odd or even", back: "Fast pointer two steps: if ends at null, even; else odd." },
    { front: "Multiply corresponding elements of two lists", back: "Traverse both, multiply values, create result list." },
    { front: "Finding maximum element", back: "Traverse, track max seen. O(n) time." },
    { front: "Count occurrences of element", back: "Traverse, increment counter when value matches." },
    { front: "Insert at nth position", back: "Traverse to (n-1)th node, update pointers. Handle edge cases." },
    { front: "Delete at nth position", back: "Traverse to (n-1)th, skip nth node. Handle head deletion." },
    { front: "Delete first occurrence of key", back: "Find node with key, update previous node's next." },
    { front: "Delete last occurrence of key", back: "Track last seen, delete at end of traversal." },
    { front: "Delete all occurrences of key", back: "Traverse entire list, skip all matching nodes." },
    { front: "Frequency of given element", back: "Count nodes matching the value. O(n) time." },
    { front: "Mean of linked list", back: "Sum all values and count nodes, divide. O(n) time." },
    { front: "Product of all elements", back: "Traverse, multiply values. Handle zero case." },
    { front: "Remove every kth node", back: "Traverse with counter, delete when counter reaches k, reset." },
    { front: "Print alternate nodes", back: "Print every other node while traversing." },
    { front: "Print elements of list in pairs", back: "Print current and next, advance by 2." },
    { front: "Alternating split", back: "Create two lists, distribute nodes alternately." },
    { front: "Identical linked lists", back: "Compare node by node: values and length must match." },
    { front: "Move last node to front", back: "Traverse to second-last, update pointers." },
    { front: "Delete middle of linked list", back: "Fast-slow pointers, delete where slow stops." },
    { front: "Make middle node head", back: "Find middle, update pointers to move it to front." },
    { front: "Sort a linked list of 0s, 1s, 2s", back: "Count occurrences, overwrite values. Or use 3 lists." },
    { front: "Delete N nodes after M nodes", back: "Keep M nodes, delete N nodes, repeat pattern." },
    { front: "Swap kth from beginning and end", back: "Find positions, swap nodes or values." },
    { front: "Point to next higher value node", back: "Merge sort list, set arbit pointers during merge." },
    { front: "Select random node with equal probability", back: "Reservoir sampling: O(n) time, O(1) space." },
    { front: "Rearrange in zig-zag fashion", back: "Alternate between < and > relationships, swap if needed." },
    { front: "Add 1 to linked list number", back: "Reverse, add 1 with carry, reverse back." },
    { front: "Segregate even and odd nodes", back: "Create two lists, one for even values, one for odd. Concatenate." },
    { front: "Flatten sorted list with next and down", back: "Merge sort on all sublists using down pointers." },
    { front: "Insert in sorted circular list", back: "Handle empty, single node, and boundary cases." },
    { front: "Exchange first and last nodes", back: "Find second-to-last, update head/tail pointers." },
    { front: "Merge sort vs quick sort for lists", back: "Merge sort better: no random access needed. O(n log n)." },
    { front: "Convert linked list to array", back: "Traverse and push values to array. O(n) time and space." },
    { front: "Convert array to linked list", back: "Iterate array, create nodes, link them together." },
    { front: "Time complexity: access by index", back: "O(n) - must traverse from head." },
    { front: "Time complexity: insertion at head", back: "O(1) - just update head pointer." },
    { front: "Time complexity: insertion at tail", back: "O(n) without tail pointer, O(1) with tail pointer." },
    { front: "Time complexity: deletion", back: "O(1) if node given, O(n) if searching for value." },
    { front: "Space per node", back: "Singly: value + pointer. Doubly: value + 2 pointers." },
    { front: "Arrays vs Linked Lists", back: "Array: O(1) access, fixed size. List: O(1) insert/delete, dynamic." },
];
