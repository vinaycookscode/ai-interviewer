// SQL & Databases - 25 Detailed Flashcards
export const SQL_CARDS = [
    { front: "What are the different types of SQL JOINs?", back: "**1. INNER JOIN:**\n- Only matching rows from both tables\n```sql\nSELECT * FROM A INNER JOIN B ON A.id = B.a_id\n```\n\n**2. LEFT (OUTER) JOIN:**\n- All rows from left + matches from right (NULL if no match)\n\n**3. RIGHT (OUTER) JOIN:**\n- All rows from right + matches from left\n\n**4. FULL (OUTER) JOIN:**\n- All rows from both (NULLs where no match)\n\n**5. CROSS JOIN:**\n- Cartesian product (every row with every row)\n\n**6. SELF JOIN:**\n- Table joined with itself (use aliases)" },
    { front: "What is the difference between WHERE and HAVING?", back: "**WHERE:**\n- Filters rows BEFORE grouping\n- Cannot use aggregate functions\n- Applied to individual rows\n\n```sql\nSELECT * FROM orders WHERE amount > 100\n```\n\n**HAVING:**\n- Filters groups AFTER GROUP BY\n- Can use aggregate functions\n- Applied to grouped results\n\n```sql\nSELECT customer_id, SUM(amount)\nFROM orders\nGROUP BY customer_id\nHAVING SUM(amount) > 1000\n```\n\n**Execution Order:**\nFROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY" },
    { front: "Explain window functions in SQL.", back: "**Window Functions:** Perform calculations across related rows without collapsing them.\n\n**Syntax:** `function() OVER (PARTITION BY col ORDER BY col)`\n\n**Common Functions:**\n```sql\n-- Row numbering\nROW_NUMBER() OVER (PARTITION BY dept ORDER BY salary DESC)\nRANK()       -- Gaps after ties: 1,1,3\nDENSE_RANK() -- No gaps: 1,1,2\n\n-- Value access\nLAG(col, n)  -- Previous row value\nLEAD(col, n) -- Next row value\n\n-- Aggregates as windows\nSUM(salary) OVER (PARTITION BY dept)  -- Running total\nAVG(salary) OVER (ORDER BY date ROWS BETWEEN 6 PRECEDING AND CURRENT ROW)\n```\n\n**Use cases:** Running totals, rankings, moving averages, comparing with previous rows" },
    { front: "What are the database normalization forms?", back: "**1NF (First Normal Form):**\n- Atomic values (no arrays/lists in cells)\n- Unique rows, primary key exists\n\n**2NF:**\n- 1NF + No partial dependencies\n- Non-key columns depend on ENTIRE primary key\n\n**3NF:**\n- 2NF + No transitive dependencies\n- Non-key columns don't depend on other non-key columns\n\n**BCNF (Boyce-Codd):**\n- Every determinant is a candidate key\n\n**Example violation (3NF):**\n```\nStudent(id, name, dept, dept_building)\n             ↑\n      dept → dept_building (transitive)\n```\n\n**Denormalization:** Intentionally violate for read performance" },
    { front: "What are database indexes and when should you use them?", back: "**Index:** Data structure for faster data retrieval (B-tree typically).\n\n**Types:**\n- **B-tree:** Default, good for ranges and equality\n- **Hash:** Equality only, very fast\n- **Full-text:** Text search\n- **Composite:** Multiple columns\n\n**When to use:**\n✅ Frequently queried columns\n✅ WHERE, JOIN, ORDER BY columns\n✅ Foreign keys\n✅ High cardinality columns\n\n**When NOT to use:**\n❌ Small tables\n❌ Frequently updated columns\n❌ Low cardinality (boolean, status)\n\n**Trade-offs:**\n- Faster reads, slower writes\n- Extra storage space\n\n```sql\nCREATE INDEX idx_name ON users(email);\nCREATE INDEX idx_composite ON orders(user_id, created_at);\n```" },
    { front: "Explain the difference between clustered and non-clustered indexes.", back: "**Clustered Index:**\n- Determines physical order of data on disk\n- Only ONE per table (usually primary key)\n- Leaf nodes contain actual data rows\n- Range queries very efficient\n\n**Non-Clustered Index:**\n- Separate structure from data\n- Multiple per table allowed\n- Leaf nodes contain pointers to data\n- Requires extra lookup (bookmark lookup)\n\n**Covering Index:**\n- Non-clustered index containing all query columns\n- Avoids table lookup entirely\n\n```sql\n-- Query: SELECT name, email FROM users WHERE email = ?\n-- Covering index:\nCREATE INDEX idx_email_cover ON users(email) INCLUDE (name);\n```\n\n**Rule:** Primary key → clustered; other lookups → non-clustered" },
    { front: "What is the difference between UNION and UNION ALL?", back: "**UNION:**\n- Combines results from multiple SELECTs\n- **Removes duplicates** (like DISTINCT)\n- Slower due to duplicate elimination\n\n```sql\nSELECT name FROM employees\nUNION\nSELECT name FROM contractors\n```\n\n**UNION ALL:**\n- Combines results\n- **Keeps all rows** including duplicates\n- Faster (no deduplication)\n\n```sql\nSELECT name FROM employees\nUNION ALL\nSELECT name FROM contractors\n```\n\n**Use UNION ALL when:**\n- You know there are no duplicates\n- You want duplicates preserved\n- Performance matters" },
    { front: "How do you find the Nth highest salary in SQL?", back: "**Method 1: Subquery**\n```sql\nSELECT MAX(salary) FROM employees\nWHERE salary < (SELECT MAX(salary) FROM employees)  -- 2nd highest\n```\n\n**Method 2: LIMIT OFFSET**\n```sql\nSELECT DISTINCT salary FROM employees\nORDER BY salary DESC\nLIMIT 1 OFFSET N-1;  -- Nth highest (0-indexed offset)\n```\n\n**Method 3: DENSE_RANK (Handles ties)**\n```sql\nSELECT salary FROM (\n    SELECT salary, DENSE_RANK() OVER (ORDER BY salary DESC) as rnk\n    FROM employees\n) ranked\nWHERE rnk = N;\n```\n\n**RANK vs DENSE_RANK:**\n- RANK: 100, 100, 80 → ranks 1, 1, 3\n- DENSE_RANK: 100, 100, 80 → ranks 1, 1, 2" },
    { front: "How do you find duplicate rows in a table?", back: "**Find duplicates:**\n```sql\nSELECT email, COUNT(*) as count\nFROM users\nGROUP BY email\nHAVING COUNT(*) > 1;\n```\n\n**Get all duplicate rows with details:**\n```sql\nSELECT * FROM users\nWHERE email IN (\n    SELECT email FROM users\n    GROUP BY email\n    HAVING COUNT(*) > 1\n);\n```\n\n**Delete duplicates (keep one):**\n```sql\n-- Using CTE and ROW_NUMBER\nWITH cte AS (\n    SELECT *, ROW_NUMBER() OVER (PARTITION BY email ORDER BY id) as rn\n    FROM users\n)\nDELETE FROM cte WHERE rn > 1;\n\n-- Alternative: Keep lowest ID\nDELETE FROM users\nWHERE id NOT IN (\n    SELECT MIN(id) FROM users GROUP BY email\n);\n```" },
    { front: "Explain database transactions and isolation levels.", back: "**Transaction:** Sequence of operations executed as single unit.\n\n**ACID Properties:**\n- Atomicity: All or nothing\n- Consistency: Valid state to valid state\n- Isolation: Concurrent transactions don't interfere\n- Durability: Committed data persists\n\n**Isolation Levels (lowest to highest):**\n\n**1. READ UNCOMMITTED:**\n- Can see uncommitted changes (dirty reads)\n\n**2. READ COMMITTED:**\n- Only see committed changes\n- Non-repeatable reads possible\n\n**3. REPEATABLE READ:**\n- Same query returns same results\n- Phantom reads possible\n\n**4. SERIALIZABLE:**\n- Full isolation (as if sequential)\n- Slowest, most locks\n\n**Problems prevented:**\n| Level | Dirty Read | Non-Repeatable | Phantom |\n|-------|------------|----------------|--------|\n| Read Uncommitted | ❌ | ❌ | ❌ |\n| Read Committed | ✅ | ❌ | ❌ |\n| Repeatable Read | ✅ | ✅ | ❌ |\n| Serializable | ✅ | ✅ | ✅ |" },
    { front: "What is the N+1 query problem and how do you solve it?", back: "**N+1 Problem:** Fetching 1 query + N additional queries for related data.\n\n**Example:**\n```python\nauthors = Author.all()  # 1 query\nfor author in authors:\n    print(author.books)  # N queries (one per author)\n```\n\n**Solutions:**\n\n**1. Eager Loading (JOIN):**\n```sql\nSELECT * FROM authors\nJOIN books ON authors.id = books.author_id;\n```\n\n**2. Batch Loading:**\n```sql\nSELECT * FROM authors;\nSELECT * FROM books WHERE author_id IN (1, 2, 3, ...);\n```\n\n**3. ORM Solutions:**\n```python\n# Django\nAuthor.objects.prefetch_related('books')\n\n# SQLAlchemy\nquery.options(joinedload(Author.books))\n```\n\n**Detection:** Enable query logging, look for repeated similar queries" },
    { front: "What is a CTE (Common Table Expression) and when would you use it?", back: "**CTE:** Named temporary result set within a single query.\n\n**Syntax:**\n```sql\nWITH cte_name AS (\n    SELECT ... \n)\nSELECT * FROM cte_name;\n```\n\n**Benefits:**\n- Improved readability\n- Can reference multiple times\n- Supports recursion\n\n**Recursive CTE Example (hierarchical data):**\n```sql\nWITH RECURSIVE org_chart AS (\n    -- Base case: top-level employees\n    SELECT id, name, manager_id, 1 as level\n    FROM employees\n    WHERE manager_id IS NULL\n    \n    UNION ALL\n    \n    -- Recursive case: employees with managers\n    SELECT e.id, e.name, e.manager_id, oc.level + 1\n    FROM employees e\n    JOIN org_chart oc ON e.manager_id = oc.id\n)\nSELECT * FROM org_chart;\n```\n\n**Use cases:** Hierarchies, running totals, breaking complex queries" },
    { front: "What is the difference between DELETE, TRUNCATE, and DROP?", back: "**DELETE:**\n```sql\nDELETE FROM table WHERE condition;\n```\n- Removes specific rows\n- Can have WHERE clause\n- Logged (can rollback)\n- Triggers fire\n- Slower for large tables\n\n**TRUNCATE:**\n```sql\nTRUNCATE TABLE table_name;\n```\n- Removes ALL rows\n- Cannot have WHERE\n- Minimal logging (faster)\n- Resets auto-increment\n- Cannot rollback (usually)\n\n**DROP:**\n```sql\nDROP TABLE table_name;\n```\n- Removes entire table structure\n- Including indexes, constraints\n- Cannot rollback\n\n**Speed:** DROP > TRUNCATE > DELETE\n\n**When to use:**\n- DELETE: Remove specific rows\n- TRUNCATE: Clear table, keep structure\n- DROP: Remove table entirely" },
    { front: "How do you handle NULL values in SQL?", back: "**NULL:** Represents unknown/missing value.\n\n**Comparison (NULL = NULL is UNKNOWN):**\n```sql\n-- Wrong:\nWHERE column = NULL\n\n-- Correct:\nWHERE column IS NULL\nWHERE column IS NOT NULL\n```\n\n**COALESCE:** Return first non-NULL\n```sql\nSELECT COALESCE(nickname, name, 'Anonymous') as display_name\n```\n\n**NULLIF:** Return NULL if equal\n```sql\nSELECT amount / NULLIF(quantity, 0)  -- Avoid divide by zero\n```\n\n**IFNULL / NVL:** Replace NULL\n```sql\nSELECT IFNULL(phone, 'N/A')  -- MySQL\nSELECT NVL(phone, 'N/A')     -- Oracle\n```\n\n**NULL in aggregates:**\n- COUNT(*) includes NULLs\n- COUNT(column) excludes NULLs\n- SUM, AVG ignore NULLs" },
    { front: "Explain EXPLAIN and how to read query execution plans.", back: "**EXPLAIN:** Shows how database will execute query.\n\n```sql\nEXPLAIN SELECT * FROM orders WHERE user_id = 5;\n```\n\n**Key things to look for:**\n\n**1. Type (access method):**\n- `const`: Single row (primary key)\n- `eq_ref`: One row per join\n- `ref`: Index lookup, multiple rows possible\n- `range`: Index range scan\n- `index`: Full index scan\n- `ALL`: Full table scan (often bad!)\n\n**2. Key:** Which index is used (NULL = no index)\n\n**3. Rows:** Estimated rows to examine\n\n**4. Extra:**\n- `Using index`: Covering index\n- `Using filesort`: Extra sorting step\n- `Using temporary`: Temp table needed\n\n**Red flags:**\n- Type = ALL on large tables\n- Large rows value\n- Using filesort + temporary" },
    { front: "What are stored procedures and when should you use them?", back: "**Stored Procedure:** Precompiled SQL code stored in database.\n\n```sql\nCREATE PROCEDURE GetUserOrders(IN user_id INT)\nBEGIN\n    SELECT * FROM orders WHERE user_id = user_id;\nEND;\n\n-- Call:\nCALL GetUserOrders(123);\n```\n\n**Advantages:**\n✅ Reduced network traffic (one call)\n✅ Precompiled (faster)\n✅ Reusable logic\n✅ Security (grant execute without table access)\n\n**Disadvantages:**\n❌ Harder to version control\n❌ Database vendor lock-in\n❌ Debugging is harder\n❌ Business logic in DB\n\n**Use when:**\n- Performance-critical operations\n- Complex multi-step transactions\n- Need fine-grained security\n\n**Avoid when:**\n- Simple CRUD operations\n- Portability is important" },
    { front: "How do database views work?", back: "**View:** Virtual table based on a query.\n\n```sql\nCREATE VIEW active_users AS\nSELECT id, name, email\nFROM users\nWHERE status = 'active';\n\n-- Use like a table:\nSELECT * FROM active_users WHERE name LIKE 'A%';\n```\n\n**Benefits:**\n- Simplify complex queries\n- Security (hide columns)\n- Abstraction layer\n- Consistent interface\n\n**Materialized View:**\n- Stores actual data (not just query)\n- Faster reads\n- Must refresh to update\n\n```sql\nCREATE MATERIALIZED VIEW monthly_sales AS\nSELECT month, SUM(amount) FROM orders GROUP BY month;\n\n-- Refresh:\nREFRESH MATERIALIZED VIEW monthly_sales;\n```\n\n**Regular vs Materialized:**\n- Regular: Always current, slower\n- Materialized: Cached, needs refresh" },
    { front: "What is connection pooling and why is it important?", back: "**Connection Pooling:** Reusing database connections instead of creating new ones.\n\n**Problem without pooling:**\n- Creating connection: 100-500ms\n- Database has connection limits\n- Each connection uses memory\n\n**How it works:**\n1. Pool maintains set of open connections\n2. App requests connection → gets from pool\n3. App done → returns to pool (not closed)\n\n**Configuration:**\n- **Min pool size:** Connections always open\n- **Max pool size:** Maximum concurrent connections\n- **Timeout:** Wait time for available connection\n\n**Example (Java HikariCP):**\n```java\nHikariConfig config = new HikariConfig();\nconfig.setMaximumPoolSize(10);\nconfig.setMinimumIdle(5);\nconfig.setConnectionTimeout(30000);\n```\n\n**Sizing:** Pool size ≈ (core_count * 2) + effective_spindle_count" },
    { front: "How do you optimize slow SQL queries?", back: "**1. Analyze with EXPLAIN:**\n- Look for full table scans\n- Check index usage\n\n**2. Add appropriate indexes:**\n```sql\nCREATE INDEX idx_user_date ON orders(user_id, created_at);\n```\n\n**3. Rewrite query:**\n- Avoid SELECT *\n- Use EXISTS instead of IN for subqueries\n- Avoid functions on indexed columns\n\n```sql\n-- Bad: WHERE YEAR(created_at) = 2024\n-- Good: WHERE created_at >= '2024-01-01'\n```\n\n**4. Denormalize if needed:**\n- Add redundant columns to avoid JOINs\n\n**5. Pagination:**\n```sql\n-- Better than OFFSET for large tables:\nWHERE id > last_seen_id LIMIT 20\n```\n\n**6. Query hints (last resort):**\n```sql\nSELECT /*+ INDEX(orders idx_user) */ ...\n```" },
    { front: "Explain database sharding strategies.", back: "**Sharding:** Horizontal partitioning across multiple databases.\n\n**Strategies:**\n\n**1. Hash-based:**\n```\nshard = hash(user_id) % num_shards\n```\n- Even distribution\n- Hard to reshard\n\n**2. Range-based:**\n```\nuser_id 1-1M → shard 1\nuser_id 1M-2M → shard 2\n```\n- Easy range queries\n- Can create hot spots\n\n**3. Directory-based:**\n- Lookup service maps key → shard\n- Flexible, adds latency\n\n**4. Geographic:**\n- US users → US datacenter\n- EU users → EU datacenter\n\n**Challenges:**\n- Cross-shard queries expensive\n- JOINs across shards not possible\n- Transactions span shards: use Saga pattern\n- Rebalancing is complex\n\n**Shard key choice is critical:** High cardinality, even distribution, query patterns" },
    { front: "What is the difference between optimistic and pessimistic locking?", back: "**Pessimistic Locking:**\n- Lock record when reading\n- Others blocked until released\n\n```sql\nSELECT * FROM accounts WHERE id = 1 FOR UPDATE;\n-- Other transactions wait here\nUPDATE accounts SET balance = balance - 100 WHERE id = 1;\nCOMMIT;\n```\n\n**Optimistic Locking:**\n- No lock when reading\n- Check for changes before writing\n- Use version/timestamp column\n\n```sql\nSELECT balance, version FROM accounts WHERE id = 1;\n-- version = 5, balance = 1000\n\nUPDATE accounts \nSET balance = 900, version = 6\nWHERE id = 1 AND version = 5;\n-- If 0 rows affected → another transaction modified it\n```\n\n**When to use:**\n| Pessimistic | Optimistic |\n|-------------|------------|\n| High contention | Low contention |\n| Short transactions | Long transactions |\n| Critical data | Retry is acceptable |" },
    { front: "How do you write a query to get employees who earn more than their manager?", back: "**Self JOIN solution:**\n\n```sql\nSELECT e.name as employee, e.salary as emp_salary,\n       m.name as manager, m.salary as mgr_salary\nFROM employees e\nJOIN employees m ON e.manager_id = m.id\nWHERE e.salary > m.salary;\n```\n\n**Schema assumed:**\n```\nemployees(id, name, salary, manager_id)\n```\n\n**Breakdown:**\n1. Self-join: employee table with itself\n2. Link employee to their manager via manager_id\n3. Filter where employee salary > manager salary\n\n**Common variations:**\n```sql\n-- Count employees earning more than manager\nSELECT COUNT(*) FROM employees e\nJOIN employees m ON e.manager_id = m.id\nWHERE e.salary > m.salary;\n\n-- Include employees without managers (LEFT JOIN)\nSELECT e.name FROM employees e\nLEFT JOIN employees m ON e.manager_id = m.id\nWHERE m.id IS NULL OR e.salary > m.salary;\n```" },
    { front: "How do you pivot data in SQL?", back: "**Pivot:** Convert rows to columns.\n\n**Sample data:**\n```\n| product | quarter | sales |\n|---------|---------|-------|\n| A       | Q1      | 100   |\n| A       | Q2      | 150   |\n| B       | Q1      | 200   |\n```\n\n**CASE WHEN approach (works everywhere):**\n```sql\nSELECT product,\n    SUM(CASE WHEN quarter = 'Q1' THEN sales ELSE 0 END) as Q1,\n    SUM(CASE WHEN quarter = 'Q2' THEN sales ELSE 0 END) as Q2\nFROM sales\nGROUP BY product;\n```\n\n**PIVOT clause (SQL Server, Oracle):**\n```sql\nSELECT *\nFROM sales\nPIVOT (\n    SUM(sales)\n    FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4')\n) as pivoted;\n```\n\n**Result:**\n```\n| product | Q1  | Q2  |\n|---------|-----|-----|\n| A       | 100 | 150 |\n| B       | 200 | 0   |\n```" },
];
