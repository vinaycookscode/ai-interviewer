// Stacks & Queues - 100 Flashcards  
export const STACKS_QUEUES_CARDS = [
    { front: "Valid Parentheses", back: "Push opening to stack. For closing, pop and compare. Stack empty = valid." },
    { front: "Implement queue using stacks", back: "Push to stack1. For pop, transfer to stack2, pop from stack2." },
    { front: "Implement stack using queues", back: "Push: enqueue to q2, transfer q1 to q2, swap. Or single queue." },
    { front: "Min Stack", back: "Store (value, current_min) pairs, or auxiliary min stack." },
    { front: "Max Stack", back: "Similar to min stack. Track max for each element." },
    { front: "Design Browser History", back: "Two stacks: back and forward. Or single list with pointer." },
    { front: "Monotonic stack: what is it?", back: "Stack maintaining increasing/decreasing order. Pop violating elements." },
    { front: "Next Greater Element", back: "Monotonic decreasing stack. Pop smaller, assign current as answer." },
    { front: "Next Smaller Element", back: "Monotonic increasing stack. Same idea, opposite direction." },
    { front: "Daily Temperatures", back: "Next greater element. Stack of indices, pop when warmer found." },
    { front: "Stock Span Problem", back: "Count consecutive smaller/equal before. Monotonic stack." },
    { front: "Largest Rectangle in Histogram", back: "Monotonic increasing stack. Pop when smaller bar found." },
    { front: "Maximal Rectangle", back: "Each row as histogram, apply largest rectangle. O(n*m)." },
    { front: "Trapping Rain Water (stack)", back: "Monotonic stack tracking heights. Calculate water when popping." },
    { front: "Remove K Digits", back: "Monotonic increasing stack. Keep k digits, remove larger ones." },
    { front: "Remove Duplicate Letters", back: "Stack + last index + in_stack tracking. Greedy smallest." },
    { front: "132 Pattern", back: "Stack tracking (max, min) pairs from right. Check for 1 < 3 > 2." },
    { front: "Basic Calculator", back: "Stack for signs. Handle +, -, parentheses." },
    { front: "Basic Calculator II", back: "Stack for numbers/operators. Handle + - * /." },
    { front: "Evaluate Reverse Polish Notation", back: "Stack: push numbers, pop two for operators, push result." },
    { front: "Decode String", back: "Stack for multipliers and strings. Process brackets." },
    { front: "Asteroid Collision", back: "Stack simulation. Compare directions, larger survives." },
    { front: "Flatten Nested List Iterator", back: "Stack of iterators. Unfold lists lazily." },
    { front: "Exclusive Time of Functions", back: "Stack of (id, time). Calculate durations on end." },
    { front: "Online Stock Span", back: "Stack of (price, span). Pop smaller, accumulate spans." },
    { front: "Score of Parentheses", back: "Stack: 0 for open. On close: pop, calculate score." },
    { front: "Minimum Remove to Make Valid Parentheses", back: "Mark invalid indices with stack. Build result." },
    { front: "Make The String Great", back: "Stack: pop if current is case-opposite of top." },
    { front: "Validate Stack Sequences", back: "Simulate: push until match pop, then pop. Check all popped." },
    { front: "Simplify Path", back: "Split by /, stack for dirs. Handle . and .. specially." },
    { front: "Backspace String Compare", back: "Stack simulation: pop on #. Or two pointers from end." },
    { front: "Implement Queue with Stack (amortized O(1))", back: "Two stacks. Only transfer when output empty. Amortized O(1)." },
    { front: "Circular Queue implementation", back: "Array with front/rear pointers. Modulo arithmetic." },
    { front: "Circular Deque implementation", back: "Double-ended circular queue. Add/remove from both ends." },
    { front: "Design Hit Counter", back: "Queue of timestamps, remove old entries. Or array of 300 buckets." },
    { front: "Moving Average from Data Stream", back: "Queue with fixed size. Track sum for O(1) average." },
    { front: "Sliding Window Maximum", back: "Monotonic decreasing deque of indices. O(n)." },
    { front: "Shortest Subarray with Sum ≥ K", back: "Monotonic deque with prefix sums. O(n)." },
    { front: "Jump Game VI", back: "DP + monotonic deque for max in window. O(n)." },
    { front: "LRU Cache", back: "HashMap + Doubly Linked List. O(1) get/put." },
    { front: "LFU Cache", back: "HashMap + frequency lists + doubly linked lists. O(1)." },
    { front: "Design Circular Queue", back: "Fixed size array with head/tail pointers." },
    { front: "First Unique Number", back: "Queue + HashMap counting. Return first with count 1." },
    { front: "Number of Recent Calls", back: "Queue of timestamps. Pop old, return size." },
    { front: "Dota2 Senate", back: "Two queues for parties. Simulate voting rounds." },
    { front: "Task Scheduler (queue)", back: "Priority queue by frequency. Handle cooldown with queue." },
    { front: "Implement Stack with Linked List", back: "Push/pop at head. O(1) operations." },
    { front: "Implement Queue with Linked List", back: "Insert at tail, remove from head. Track both." },
    { front: "Two Stacks in One Array", back: "One from start, one from end. Meet in middle." },
    { front: "K Stacks in One Array", back: "Array + top pointers + next array. Clever indexing." },
    { front: "Stack Permutations", back: "Check if output sequence achievable. Simulate push/pop." },
    { front: "Sort a Stack", back: "Use auxiliary stack. O(n²) time." },
    { front: "Reverse a Stack", back: "Recursion: pop, reverse, insert at bottom." },
    { front: "Insert at Bottom of Stack", back: "Pop all, insert, push all back." },
    { front: "Delete Middle of Stack", back: "Pop to count, delete at middle, push back." },
    { front: "Tower of Hanoi", back: "Recursive: move n-1 to aux, move 1 to dest, move n-1 to dest." },
    { front: "Infix to Postfix", back: "Stack for operators. Output operands, handle precedence." },
    { front: "Infix to Prefix", back: "Reverse, infix to postfix (swap parens), reverse result." },
    { front: "Evaluate Postfix", back: "Stack: push numbers, pop for operators, push result." },
    { front: "Evaluate Prefix", back: "Traverse right to left, same as postfix." },
    { front: "Expression Tree from Postfix", back: "Stack of nodes. Create node for operator, pop children." },
    { front: "Check for Balanced Expression", back: "Stack for opening brackets. Match types correctly." },
    { front: "Redundant Parentheses", back: "Stack: if no operator between matching parens, redundant." },
    { front: "Longest Valid Parentheses", back: "Stack of indices. Track valid start position." },
    { front: "Maximum Nesting Depth", back: "Track max stack size during balanced check." },
    { front: "Remove Outermost Parentheses", back: "Track depth, include only when depth > 0." },
    { front: "Celebrity Problem", back: "Stack elimination. Celebrity knows no one, known by all." },
    { front: "Stock Buy Sell with Multiple Transactions", back: "Stack: track local minima and maxima." },
    { front: "Maximum Area Rectangle in Binary Matrix", back: "Histogram method per row. Stack for each histogram." },
    { front: "Sum of Subarray Minimums", back: "Monotonic stack. Contribution of each element." },
    { front: "Sum of Subarray Maximums", back: "Similar, use increasing stack instead." },
    { front: "Car Fleet II", back: "Process right to left with stack. Calculate collision times." },
    { front: "Final Prices With Discount", back: "Next smaller element. Apply discount." },
    { front: "Buildings With Ocean View", back: "Traverse right to left, track max height." },
    { front: "Number of Visible People in Queue", back: "Monotonic stack from right. Count visible." },
    { front: "Steps to Make Array Non-decreasing", back: "Stack tracking steps to remove each element." },
    { front: "Maximum Width Ramp", back: "Stack of candidates for min, binary search for max." },
    { front: "Odd Even Jump", back: "Monotonic stacks for higher/lower jumps. DP." },
    { front: "132 Pattern Count", back: "Stack tracking potential patterns." },
    { front: "Next Greater Frequency Element", back: "Count frequencies, then next greater element idea." },
    { front: "Online Majority Element In Subarray", back: "RandomizedSet + segment tree or block decomposition." },
    { front: "Maximum of Minimum for Every Window Size", back: "Stack for next/prev smaller. O(n)." },
    { front: "Sliding Window Median", back: "Two heaps or two balanced BSTs." },
    { front: "Maximum Sum Circular Subarray (deque)", back: "Kadane + min subarray, or sliding window with deque." },
    { front: "Constrained Subsequence Sum", back: "DP + monotonic deque for max. O(n)." },
    { front: "Shortest Unsorted Continuous Subarray (stack)", back: "Find left/right bounds using stack." },
    { front: "Number of Subarrays with Bounded Maximum", back: "Count subarrays contribution at each position." },
    { front: "Design Snake Game", back: "Deque for snake body. HashSet for quick lookup." },
    { front: "Design Tic-Tac-Toe", back: "Track row/col sums. Check win in O(1)." },
    { front: "Implement Trie (Prefix Tree)", back: "Node with children map and end flag. O(m) operations." },
    { front: "Design Twitter", back: "HashMap of user tweets and follows. Merge k feeds." },
    { front: "Design Underground System", back: "HashMap of check-ins. Calculate average times." },
    { front: "Text Editor", back: "Two stacks: left and right of cursor." },
    { front: "Undo/Redo Implementation", back: "Two stacks: operations and undone. Push/pop between." },
    { front: "Minimum Add to Make Parentheses Valid", back: "Track unmatched opens and closes." },
    { front: "Valid Parentheses String", back: "Track range of open count (min, max). Wildcard handling." },
    { front: "Different Ways to Add Parentheses", back: "Divide and conquer at operators. Stack for evaluation." },
    { front: "Generate Parentheses", back: "Backtracking with open/close counts." },
    { front: "Remove Invalid Parentheses", back: "BFS for minimum removals. Or backtracking with pruning." },
];
