// Binary Trees - 50 Flashcards with Detailed Content
export const TREES_CARDS = [
    { front: "What are the three depth-first traversals of a binary tree and when would you use each?", back: "**DFS Traversals:**\n\n**1. Inorder (Left → Root → Right)**\n- Visits BST nodes in sorted order\n- Use for: BST validation, finding kth smallest\n\n**2. Preorder (Root → Left → Right)**\n- Copies tree structure perfectly\n- Use for: serialization, prefix expression\n\n**3. Postorder (Left → Right → Root)**\n- Processes children before parent\n- Use for: delete tree, postfix expression, calculating height\n\n**Implementation:**\n```\ndef inorder(node):\n    if node:\n        inorder(node.left)\n        visit(node)\n        inorder(node.right)\n```" },
    { front: "How do you perform a level-order (BFS) traversal of a binary tree?", back: "**Queue-Based BFS: O(n) time, O(n) space**\n\n```\ndef levelOrder(root):\n    if not root: return []\n    \n    result = []\n    queue = [root]\n    \n    while queue:\n        level_size = len(queue)\n        current_level = []\n        \n        for _ in range(level_size):\n            node = queue.pop(0)\n            current_level.append(node.val)\n            \n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        \n        result.append(current_level)\n    \n    return result\n```\n\n**Applications:**\n- Level-by-level printing\n- Finding minimum depth (first leaf found)\n- Zigzag traversal (reverse alternate levels)\n- Right/Left view (first/last of each level)" },
    { front: "How do you calculate the height (or maximum depth) of a binary tree?", back: "**Recursive DFS: O(n) time, O(h) space**\n\n```\ndef maxDepth(root):\n    if root is None:\n        return 0\n    \n    left_height = maxDepth(root.left)\n    right_height = maxDepth(root.right)\n    \n    return 1 + max(left_height, right_height)\n```\n\n**Iterative BFS Alternative:**\n- Count number of levels during level-order traversal\n\n**Height vs Depth:**\n- Height: edges from node to deepest leaf\n- Depth: edges from root to node\n- Tree height = max depth of any node\n\n**Example:**\n```\n    1\n   / \\\n  2   3\n / \\\n4   5\n```\nHeight = 3 levels = depth 2 (counting edges)" },
    { front: "How do you check if a binary tree is balanced (height-balanced)?", back: "**Bottom-Up DFS: O(n) time - single pass**\n\n```\ndef isBalanced(root):\n    def checkHeight(node):\n        if node is None:\n            return 0\n        \n        left = checkHeight(node.left)\n        if left == -1: return -1  # Left subtree unbalanced\n        \n        right = checkHeight(node.right)\n        if right == -1: return -1  # Right subtree unbalanced\n        \n        if abs(left - right) > 1:\n            return -1  # Current node unbalanced\n        \n        return 1 + max(left, right)\n    \n    return checkHeight(root) != -1\n```\n\n**Definition:** A tree is balanced if for every node:\n- Height difference between left and right subtrees ≤ 1\n- Both subtrees are also balanced\n\n**Why bottom-up?** Avoids recalculating heights multiple times (O(n) vs O(n²) top-down)." },
    { front: "How do you find the Lowest Common Ancestor (LCA) of two nodes in a binary tree?", back: "**Recursive Solution: O(n) time**\n\n```\ndef lowestCommonAncestor(root, p, q):\n    if root is None:\n        return None\n    \n    # If current node is p or q, it's the LCA\n    if root == p or root == q:\n        return root\n    \n    left = lowestCommonAncestor(root.left, p, q)\n    right = lowestCommonAncestor(root.right, p, q)\n    \n    # If p and q are in different subtrees\n    if left and right:\n        return root  # Current node is LCA\n    \n    # Both in same subtree\n    return left if left else right\n```\n\n**For BST (optimized):**\n- If both < root: go left\n- If both > root: go right\n- Otherwise: root is LCA\n\n**Applications:**\n- Finding path between two nodes\n- Distance between nodes = dist(root,p) + dist(root,q) - 2×dist(root,LCA)" },
    { front: "How do you validate if a binary tree is a valid Binary Search Tree (BST)?", back: "**Range-Based Approach: O(n) time**\n\n```\ndef isValidBST(root, min_val=float('-inf'), max_val=float('inf')):\n    if root is None:\n        return True\n    \n    # Check if current value is within valid range\n    if root.val <= min_val or root.val >= max_val:\n        return False\n    \n    # Left subtree: all values must be < root.val\n    # Right subtree: all values must be > root.val\n    return (isValidBST(root.left, min_val, root.val) and\n            isValidBST(root.right, root.val, max_val))\n```\n\n**Alternative: Inorder Traversal**\n- Inorder of valid BST produces sorted sequence\n- Check each value > previous value\n\n**Common Mistake:** Only comparing with direct parent\n- Node 5 in left subtree of 10 but right of 3 must satisfy: 3 < 5 < 10" },
    { front: "How do you serialize and deserialize a binary tree?", back: "**Preorder with Null Markers: O(n) for both operations**\n\n**Serialize:**\n```\ndef serialize(root):\n    if root is None:\n        return \"#\"  # Null marker\n    \n    return str(root.val) + \",\" + serialize(root.left) + \",\" + serialize(root.right)\n```\n\n**Deserialize:**\n```\ndef deserialize(data):\n    values = iter(data.split(','))\n    \n    def build():\n        val = next(values)\n        if val == '#':\n            return None\n        \n        node = TreeNode(int(val))\n        node.left = build()\n        node.right = build()\n        return node\n    \n    return build()\n```\n\n**Example:**\n```\n    1\n   / \\\n  2   3\n     / \\\n    4   5\n```\nSerialized: \"1,2,#,#,3,4,#,#,5,#,#\"" },
    { front: "How do you invert (mirror) a binary tree?", back: "**Recursive Solution: O(n) time, O(h) space**\n\n```\ndef invertTree(root):\n    if root is None:\n        return None\n    \n    # Swap left and right children\n    root.left, root.right = root.right, root.left\n    \n    # Recursively invert subtrees\n    invertTree(root.left)\n    invertTree(root.right)\n    \n    return root\n```\n\n**Iterative BFS:**\n```\ndef invertTree(root):\n    if not root: return None\n    \n    queue = [root]\n    while queue:\n        node = queue.pop(0)\n        node.left, node.right = node.right, node.left\n        if node.left: queue.append(node.left)\n        if node.right: queue.append(node.right)\n    \n    return root\n```\n\n**Example:**\n```\n    4            4\n   / \\   →     / \\\n  2   7       7   2\n / \\ / \\     / \\ / \\\n1  3 6  9   9  6 3  1\n```" },
    { front: "How do you check if two binary trees are the same (identical)?", back: "**Recursive Comparison: O(n) time**\n\n```\ndef isSameTree(p, q):\n    # Both empty\n    if not p and not q:\n        return True\n    \n    # One empty, one not\n    if not p or not q:\n        return False\n    \n    # Both non-empty: compare values and subtrees\n    return (p.val == q.val and\n            isSameTree(p.left, q.left) and\n            isSameTree(p.right, q.right))\n```\n\n**Iterative with Queue:**\n```\ndef isSameTree(p, q):\n    queue = [(p, q)]\n    while queue:\n        n1, n2 = queue.pop(0)\n        if not n1 and not n2: continue\n        if not n1 or not n2: return False\n        if n1.val != n2.val: return False\n        queue.append((n1.left, n2.left))\n        queue.append((n1.right, n2.right))\n    return True\n```\n\n**Use Case:** Checking if a tree is a subtree of another tree." },
    { front: "How do you check if a binary tree is symmetric (mirror of itself)?", back: "**Compare Left and Right Subtrees: O(n) time**\n\n```\ndef isSymmetric(root):\n    def isMirror(left, right):\n        if not left and not right:\n            return True\n        if not left or not right:\n            return False\n        \n        return (left.val == right.val and\n                isMirror(left.left, right.right) and\n                isMirror(left.right, right.left))\n    \n    if not root:\n        return True\n    \n    return isMirror(root.left, root.right)\n```\n\n**Key Insight:** For symmetry:\n- left.left mirrors right.right\n- left.right mirrors right.left\n\n**Example:**\n```\n    1           Symmetric\n   / \\\n  2   2\n / \\ / \\\n3  4 4  3\n```" },
    { front: "How do you determine if there's a root-to-leaf path with a given sum?", back: "**Recursive DFS: O(n) time**\n\n```\ndef hasPathSum(root, targetSum):\n    if root is None:\n        return False\n    \n    # Check if it's a leaf and sum matches\n    if not root.left and not root.right:\n        return root.val == targetSum\n    \n    # Check left or right subtrees with reduced sum\n    remaining = targetSum - root.val\n    return (hasPathSum(root.left, remaining) or\n            hasPathSum(root.right, remaining))\n```\n\n**To find all paths (Path Sum II):**\n```\ndef pathSum(root, targetSum):\n    result = []\n    \n    def dfs(node, remaining, path):\n        if not node: return\n        \n        path.append(node.val)\n        \n        if not node.left and not node.right and remaining == node.val:\n            result.append(path.copy())\n        \n        dfs(node.left, remaining - node.val, path)\n        dfs(node.right, remaining - node.val, path)\n        \n        path.pop()  # Backtrack\n    \n    dfs(root, targetSum, [])\n    return result\n```" },
    { front: "How do you find the maximum path sum in a binary tree (path can start and end anywhere)?", back: "**Global Maximum with Local Tracking: O(n) time**\n\n```\ndef maxPathSum(root):\n    max_sum = float('-inf')\n    \n    def maxGain(node):\n        nonlocal max_sum\n        \n        if not node:\n            return 0\n        \n        # Max sum of path going through left/right child\n        # Take max with 0 to ignore negative paths\n        left_gain = max(maxGain(node.left), 0)\n        right_gain = max(maxGain(node.right), 0)\n        \n        # Path through current node as highest point\n        path_through_node = node.val + left_gain + right_gain\n        \n        # Update global maximum\n        max_sum = max(max_sum, path_through_node)\n        \n        # Return max gain if continuing path upward (can only go one direction)\n        return node.val + max(left_gain, right_gain)\n    \n    maxGain(root)\n    return max_sum\n```\n\n**Key Insight:**\n- A node can either connect left+right (forming peak) OR extend to parent\n- Track global max for peaks, return single-branch max for parent" },
    { front: "How do you calculate the diameter of a binary tree?", back: "**Track Longest Path Through Each Node: O(n) time**\n\n```\ndef diameterOfBinaryTree(root):\n    diameter = 0\n    \n    def height(node):\n        nonlocal diameter\n        \n        if not node:\n            return 0\n        \n        left_height = height(node.left)\n        right_height = height(node.right)\n        \n        # Diameter through this node = left_height + right_height\n        diameter = max(diameter, left_height + right_height)\n        \n        # Return height of this subtree\n        return 1 + max(left_height, right_height)\n    \n    height(root)\n    return diameter\n```\n\n**Definition:** Diameter is the longest path between any two nodes (may or may not pass through root).\n\n**Example:**\n```\n        1\n       / \\\n      2   3\n     / \\\n    4   5\n```\nDiameter = 3 (path: 4 → 2 → 1 → 3 or 5 → 2 → 1 → 3)" },
    { front: "How do you flatten a binary tree to a linked list in-place (preorder)?", back: "**Morris-like In-Place: O(n) time, O(1) space**\n\n```\ndef flatten(root):\n    current = root\n    \n    while current:\n        if current.left:\n            # Find rightmost node of left subtree\n            rightmost = current.left\n            while rightmost.right:\n                rightmost = rightmost.right\n            \n            # Connect rightmost to current's right subtree\n            rightmost.right = current.right\n            \n            # Move left subtree to right\n            current.right = current.left\n            current.left = None\n        \n        current = current.right\n```\n\n**Result:** All nodes connected via right pointers in preorder.\n\n**Example:**\n```\n    1        1\n   / \\        \\\n  2   5   →   2\n / \\   \\       \\\n3   4   6      3\n                \\\n                 4\n                  \\\n                   5\n                    \\\n                     6\n```" },
    { front: "How do you construct a binary tree from preorder and inorder traversals?", back: "**Recursive Division: O(n) time with HashMap**\n\n```\ndef buildTree(preorder, inorder):\n    # Map values to indices in inorder for O(1) lookup\n    inorder_map = {val: idx for idx, val in enumerate(inorder)}\n    preorder_idx = [0]  # Use list to maintain state across calls\n    \n    def build(left, right):\n        if left > right:\n            return None\n        \n        # First element in preorder is root\n        root_val = preorder[preorder_idx[0]]\n        preorder_idx[0] += 1\n        \n        root = TreeNode(root_val)\n        \n        # Split inorder into left and right subtrees\n        mid = inorder_map[root_val]\n        \n        root.left = build(left, mid - 1)  # Build left first!\n        root.right = build(mid + 1, right)\n        \n        return root\n    \n    return build(0, len(inorder) - 1)\n```\n\n**Key Insight:**\n- Preorder: root is always first\n- Inorder: root divides left and right subtrees\n- Must build left subtree before right (preorder sequence)" },
    { front: "How do you convert a sorted array to a height-balanced Binary Search Tree?", back: "**Divide and Conquer: O(n) time**\n\n```\ndef sortedArrayToBST(nums):\n    def build(left, right):\n        if left > right:\n            return None\n        \n        # Choose middle element as root\n        mid = (left + right) // 2\n        \n        root = TreeNode(nums[mid])\n        root.left = build(left, mid - 1)\n        root.right = build(mid + 1, right)\n        \n        return root\n    \n    return build(0, len(nums) - 1)\n```\n\n**Why middle element?**\n- Ensures roughly equal number of nodes on each side\n- Creates balanced tree with O(log n) height\n\n**Example:** [1, 2, 3, 4, 5, 6, 7]\n```\n       4\n      / \\\n     2   6\n    / \\ / \\\n   1  3 5  7\n```\n\n**For sorted linked list:** Use slow/fast pointers to find middle." },
    { front: "How do you find the kth smallest element in a BST?", back: "**Inorder Traversal with Counter: O(H + k) time**\n\n```\ndef kthSmallest(root, k):\n    stack = []\n    current = root\n    count = 0\n    \n    while stack or current:\n        # Go to leftmost node\n        while current:\n            stack.append(current)\n            current = current.left\n        \n        current = stack.pop()\n        count += 1\n        \n        if count == k:\n            return current.val\n        \n        current = current.right\n    \n    return -1  # k is invalid\n```\n\n**Why inorder?** BST inorder traversal visits nodes in sorted order.\n\n**Optimization for frequent queries:**\n- Store subtree size at each node\n- If left subtree size = k-1: root is answer\n- If left subtree size ≥ k: search left\n- Otherwise: search right with k = k - left_size - 1" },
    { front: "How do you implement a BST Iterator that returns elements in sorted order?", back: "**Controlled Inorder using Stack: O(h) space, O(1) amortized per call**\n\n```\nclass BSTIterator:\n    def __init__(self, root):\n        self.stack = []\n        self._push_left(root)\n    \n    def _push_left(self, node):\n        # Push all left children to stack\n        while node:\n            self.stack.append(node)\n            node = node.left\n    \n    def next(self) -> int:\n        # Pop the next smallest element\n        node = self.stack.pop()\n        \n        # Push left children of right subtree\n        if node.right:\n            self._push_left(node.right)\n        \n        return node.val\n    \n    def hasNext(self) -> bool:\n        return len(self.stack) > 0\n```\n\n**Usage:**\n```\niterator = BSTIterator(root)\nwhile iterator.hasNext():\n    print(iterator.next())\n```\n\n**Key Insight:** We don't fully traverse the tree upfront; we control the inorder traversal step by step." },
    { front: "How do you recover a BST where two nodes have been swapped by mistake?", back: "**Inorder with Violation Detection: O(n) time, O(1) space**\n\n```\ndef recoverTree(root):\n    first = second = prev = None\n    \n    def inorder(node):\n        nonlocal first, second, prev\n        \n        if not node:\n            return\n        \n        inorder(node.left)\n        \n        # Detect violation: prev > current\n        if prev and prev.val > node.val:\n            if not first:\n                first = prev  # First violation: wrong is prev\n            second = node     # Second or only violation: wrong is current\n        \n        prev = node\n        inorder(node.right)\n    \n    inorder(root)\n    \n    # Swap values of the two nodes\n    first.val, second.val = second.val, first.val\n```\n\n**Why two pointers?**\n- If swapped nodes are adjacent: one violation (first=larger, second=smaller)\n- If not adjacent: two violations (first from first, second from second)\n\n**Example:** [3, 2, 1] should be [1, 2, 3]\n- First violation: 3 > 2 → first = 3\n- Second violation: 2 > 1 → second = 1\n- Swap 3 and 1" },
    { front: "How do you perform vertical order traversal of a binary tree?", back: "**BFS with Column Tracking: O(n log n) time**\n\n```\ndef verticalOrder(root):\n    if not root:\n        return []\n    \n    column_table = defaultdict(list)\n    queue = [(root, 0)]  # (node, column)\n    \n    min_col = max_col = 0\n    \n    while queue:\n        node, col = queue.pop(0)\n        column_table[col].append(node.val)\n        \n        min_col = min(min_col, col)\n        max_col = max(max_col, col)\n        \n        if node.left:\n            queue.append((node.left, col - 1))\n        if node.right:\n            queue.append((node.right, col + 1))\n    \n    # Return columns from left to right\n    return [column_table[col] for col in range(min_col, max_col + 1)]\n```\n\n**Column Assignment:**\n- Root: column 0\n- Left child: column - 1\n- Right child: column + 1\n\n**For same row + column:** Sort by node value (requires more complex tracking with row index)." },
    { front: "What is the difference between AVL Trees and Red-Black Trees?", back: "**AVL Tree:**\n- **Balance Factor:** |height(left) - height(right)| ≤ 1\n- **Rotations:** Single or double rotations to rebalance\n- **Height:** At most 1.44 × log₂(n)\n- **Best for:** Read-heavy workloads (faster lookups)\n\n**Red-Black Tree:**\n- **Properties:** \n  1. Every node is red or black\n  2. Root is black\n  3. Red nodes have black children\n  4. All paths have equal black nodes\n- **Height:** At most 2 × log₂(n)\n- **Best for:** Write-heavy workloads (fewer rotations)\n\n**Comparison:**\n| Feature | AVL | Red-Black |\n|---------|-----|----------|\n| Search | O(log n), faster | O(log n), slightly slower |\n| Insert | O(log n), more rotations | O(log n), ≤2 rotations |\n| Delete | O(log n), more rotations | O(log n), ≤3 rotations |\n| Balance | Stricter | More relaxed |\n\n**Used in:** AVL: databases. RB: Java TreeMap, C++ map/set." },
    { front: "What is a Trie (Prefix Tree) and what are its operations?", back: "**Trie:** Tree for storing strings where each node represents a character.\n\n**Structure:**\n```\nclass TrieNode:\n    def __init__(self):\n        self.children = {}  # char → TrieNode\n        self.is_end = False\n```\n\n**Insert - O(m):**\n```\ndef insert(self, word):\n    node = self.root\n    for char in word:\n        if char not in node.children:\n            node.children[char] = TrieNode()\n        node = node.children[char]\n    node.is_end = True\n```\n\n**Search - O(m):**\n```\ndef search(self, word):\n    node = self._traverse(word)\n    return node is not None and node.is_end\n```\n\n**StartsWith - O(m):**\n```\ndef startsWith(self, prefix):\n    return self._traverse(prefix) is not None\n```\n\n**Applications:**\n- Autocomplete\n- Spell checker\n- IP routing\n- Word games (Boggle, Scrabble)" },
    { front: "What is a Segment Tree and when would you use it?", back: "**Segment Tree:** Binary tree for range queries and updates on arrays.\n\n**Operations - O(log n):**\n- Query: Range sum, min, max, etc.\n- Update: Point or range updates\n\n**Build - O(n):**\n```\ndef build(arr, node, start, end):\n    if start == end:\n        tree[node] = arr[start]\n    else:\n        mid = (start + end) // 2\n        build(arr, 2*node, start, mid)\n        build(arr, 2*node+1, mid+1, end)\n        tree[node] = tree[2*node] + tree[2*node+1]\n```\n\n**Query - O(log n):**\n```\ndef query(node, start, end, l, r):\n    if r < start or l > end:  # Outside range\n        return 0\n    if l <= start and end <= r:  # Fully inside\n        return tree[node]\n    mid = (start + end) // 2\n    return query(2*node, start, mid, l, r) + \n           query(2*node+1, mid+1, end, l, r)\n```\n\n**Use Cases:**\n- Range sum with updates\n- Range minimum query\n- Count inversions\n- Lazy propagation for range updates" },
    { front: "What is Morris Traversal and why is it useful?", back: "**Morris Traversal:** Inorder traversal without recursion or stack - O(1) space!\n\n**Algorithm:**\n```\ndef morrisInorder(root):\n    current = root\n    result = []\n    \n    while current:\n        if not current.left:\n            result.append(current.val)\n            current = current.right\n        else:\n            # Find inorder predecessor\n            predecessor = current.left\n            while predecessor.right and predecessor.right != current:\n                predecessor = predecessor.right\n            \n            if not predecessor.right:\n                # Make current the right child of predecessor\n                predecessor.right = current\n                current = current.left\n            else:\n                # Revert the changes (restore tree)\n                predecessor.right = None\n                result.append(current.val)\n                current = current.right\n    \n    return result\n```\n\n**Key Idea:**\n- Use empty right pointers of predecessors as \"threads\" back to successors\n- Temporarily modify tree, then restore\n\n**Why useful?**\n- O(1) space (no stack/recursion)\n- O(n) time (each edge visited twice)\n- Tree structure preserved after traversal" },
    { front: "How do you find all nodes at distance K from a target node in a binary tree?", back: "**Convert to Graph + BFS: O(n) time**\n\n```\ndef distanceK(root, target, k):\n    # Step 1: Build parent pointers using BFS/DFS\n    parent = {}\n    \n    def buildParent(node, par):\n        if node:\n            parent[node] = par\n            buildParent(node.left, node)\n            buildParent(node.right, node)\n    \n    buildParent(root, None)\n    \n    # Step 2: BFS from target node\n    queue = [target]\n    visited = {target}\n    distance = 0\n    \n    while queue:\n        if distance == k:\n            return [node.val for node in queue]\n        \n        for _ in range(len(queue)):\n            node = queue.pop(0)\n            \n            # Explore all neighbors (left, right, parent)\n            for neighbor in [node.left, node.right, parent[node]]:\n                if neighbor and neighbor not in visited:\n                    visited.add(neighbor)\n                    queue.append(neighbor)\n        \n        distance += 1\n    \n    return []\n```\n\n**Key Insight:** With parent pointers, tree becomes undirected graph. Then simple BFS from target." },
    { front: "How do you determine the maximum width of a binary tree?", back: "**BFS with Position Indexing: O(n) time**\n\n```\ndef widthOfBinaryTree(root):\n    if not root:\n        return 0\n    \n    max_width = 0\n    queue = [(root, 0)]  # (node, position)\n    \n    while queue:\n        level_size = len(queue)\n        _, first_pos = queue[0]\n        _, last_pos = queue[-1]\n        \n        max_width = max(max_width, last_pos - first_pos + 1)\n        \n        for _ in range(level_size):\n            node, pos = queue.pop(0)\n            \n            # Children positions (heap-style indexing)\n            if node.left:\n                queue.append((node.left, 2 * pos))\n            if node.right:\n                queue.append((node.right, 2 * pos + 1))\n    \n    return max_width\n```\n\n**Position Formula (like heap):**\n- Left child of position i: 2*i\n- Right child of position i: 2*i + 1\n\n**Width = rightmost_position - leftmost_position + 1**\n\n**Note:** Normalize positions each level to avoid integer overflow for deep trees." },
];
