// Sorting & Searching - 100 Flashcards
export const SORTING_CARDS = [
    { front: "Quick Sort time complexity?", back: "Average: O(n log n), Worst: O(n²) when pivot is always min/max." },
    { front: "Merge Sort time complexity?", back: "O(n log n) always. Stable, but O(n) extra space." },
    { front: "Quick Sort: how to choose pivot?", back: "Random, median-of-three, or middle element. Avoid sorted data worst case." },
    { front: "Merge Sort: how does merge work?", back: "Two pointers comparing sorted halves, merge into result array." },
    { front: "Heap Sort complexity?", back: "O(n log n) always. In-place but not stable." },
    { front: "Counting Sort complexity?", back: "O(n+k) where k is range. Good for small integer ranges." },
    { front: "Radix Sort complexity?", back: "O(d*(n+k)) where d is digits, k is base. Good for integers." },
    { front: "Bucket Sort complexity?", back: "O(n+k) average. Distributes elements into buckets." },
    { front: "Insertion Sort: when is it good?", back: "Small arrays, nearly sorted data. O(n) best case." },
    { front: "Bubble Sort complexity?", back: "O(n²) average/worst. Simple but slow." },
    { front: "Selection Sort complexity?", back: "O(n²) always. Minimizes swaps." },
    { front: "What makes a sort stable?", back: "Equal elements maintain relative order." },
    { front: "What makes a sort in-place?", back: "O(1) extra space. Modifies input array." },
    { front: "Quick Select algorithm", back: "Find kth element. Partition, recurse on one side. O(n) average." },
    { front: "Quick Select worst case?", back: "O(n²) if bad pivots. Use median-of-medians for O(n) guaranteed." },
    { front: "Median-of-medians algorithm", back: "Find approximate median in O(n) for guaranteed O(n) selection." },
    { front: "Binary Search: basic template", back: "left=0, right=n-1. mid=(left+right)/2. Adjust based on comparison." },
    { front: "Binary Search: lower_bound", back: "Find first element >= target. If equal, continue left." },
    { front: "Binary Search: upper_bound", back: "Find first element > target." },
    { front: "Binary Search on answer", back: "Search space is answer range. Check if answer is valid." },
    { front: "Search in rotated sorted array", back: "Find sorted half, check if target in range. O(log n)." },
    { front: "Find minimum in rotated array", back: "Compare mid with right. If mid > right, min on right." },
    { front: "Find peak element", back: "If mid > mid+1, peak on left. Else on right. O(log n)." },
    { front: "Search in 2D sorted matrix", back: "Flatten to 1D binary search, or search from corner." },
    { front: "Kth smallest element in sorted matrix", back: "Binary search on value range, count elements ≤ mid." },
    { front: "First bad version", back: "Binary search to find transition from good to bad." },
    { front: "Sqrt(x) with binary search", back: "Search 0 to x. If mid² ≤ x < (mid+1)², return mid." },
    { front: "Pow(x, n) binary exponentiation", back: "x^n = x^(n/2) * x^(n/2). O(log n)." },
    { front: "Search insert position", back: "Binary search. If not found, left is insert position." },
    { front: "Find first and last position", back: "Two binary searches: one for first, one for last." },
    { front: "Single element in sorted array", back: "Binary search: before single, pairs start at even index." },
    { front: "Split Array Largest Sum", back: "Binary search on answer, greedy check if achievable." },
    { front: "Capacity to Ship Packages", back: "Binary search on capacity, check if can ship in D days." },
    { front: "Koko Eating Bananas", back: "Binary search on speed, check if can finish in H hours." },
    { front: "Aggressive Cows", back: "Binary search on min distance, check if can place cows." },
    { front: "Book Allocation", back: "Binary search on max pages, check if can allocate to m students." },
    { front: "Painter's Partition", back: "Binary search on time, check if k painters can finish." },
    { front: "Median of two sorted arrays", back: "Binary search on partition. O(log(min(m,n)))." },
    { front: "Find Kth element of two sorted arrays", back: "Binary search eliminating k/2 elements each time." },
    { front: "Longest Increasing Subsequence O(n log n)", back: "Binary search on tail array. Patient sort." },
    { front: "Dutch National Flag algorithm", back: "Three pointers: low, mid, high. Sort 0s, 1s, 2s." },
    { front: "Sort colors", back: "Dutch National Flag. O(n) one pass." },
    { front: "Sort array of 0s, 1s, 2s", back: "Same as sort colors. Three-way partition." },
    { front: "Sort array by parity", back: "Two pointers: even left, odd right." },
    { front: "Wiggle Sort", back: "nums[0] ≤ nums[1] ≥ nums[2] ≤ ... Swap adjacent if needed." },
    { front: "Wiggle Sort II", back: "Median + three-way partition. O(n) optimal." },
    { front: "Merge sorted array (in-place)", back: "Fill from end. Two pointers from ends of both arrays." },
    { front: "Intersection of two sorted arrays", back: "Two pointers. If equal, add to result, move both." },
    { front: "Union of two sorted arrays", back: "Like merge, add distinct elements." },
    { front: "Find the duplicate number", back: "Floyd's cycle detection in linked list interpretation." },
    { front: "Find all duplicates in array", back: "Mark visited by negating value. If already negative, duplicate." },
    { front: "First missing positive", back: "Place each num at index num-1. First mismatch is answer." },
    { front: "H-Index", back: "Sort descending, find i where citations[i] >= i+1." },
    { front: "H-Index II (sorted)", back: "Binary search for n - mid <= citations[mid]." },
    { front: "Meeting Rooms (can attend all?)", back: "Sort by start, check overlaps." },
    { front: "Meeting Rooms II (min rooms)", back: "Sort by start, heap for end times. O(n log n)." },
    { front: "Merge Intervals", back: "Sort by start, merge overlapping. O(n log n)." },
    { front: "Insert Interval", back: "Find position, merge with overlapping intervals." },
    { front: "Non-overlapping Intervals", back: "Sort by end, greedy count non-overlapping." },
    { front: "Interval List Intersections", back: "Two pointers on sorted lists, find overlaps." },
    { front: "Employee Free Time", back: "Merge all intervals, find gaps." },
    { front: "Car Fleet", back: "Sort by position, count fleets that arrive independently." },
    { front: "Queue Reconstruction by Height", back: "Sort by height desc, k asc. Insert at index k." },
    { front: "Largest Number", back: "Sort with custom comparator: a+b > b+a." },
    { front: "Valid Triangle Number", back: "Sort, fix largest, two pointers for smaller two." },
    { front: "3Sum Closest", back: "Sort, fix one, two pointers, track closest sum." },
    { front: "4Sum", back: "Fix two, two pointers for remaining. O(n³)." },
    { front: "Count of Smaller Numbers After Self", back: "Merge sort with counting, or BST/BIT." },
    { front: "Reverse Pairs", back: "Merge sort: count pairs during merge." },
    { front: "Count of Range Sum", back: "Merge sort on prefix sums." },
    { front: "Maximum Gap", back: "Bucket sort. Gap must be at least (max-min)/(n-1)." },
    { front: "Contains Duplicate", back: "HashSet check. O(n) time." },
    { front: "Contains Duplicate II", back: "HashSet with sliding window of size k." },
    { front: "Contains Duplicate III", back: "Buckets of size t+1, or balanced BST." },
    { front: "Top K Frequent Elements", back: "Count + min-heap of size k. Or bucket sort by frequency." },
    { front: "Kth Largest Element", back: "QuickSelect O(n) average, or max-heap O(n + k log n)." },
    { front: "Sort List (linked list)", back: "Merge sort. Find middle, sort halves, merge." },
    { front: "Insertion Sort List", back: "Build sorted list by inserting each node correctly." },
    { front: "Pancake Sorting", back: "Find max, flip to front, flip to position. O(n²)." },
    { front: "Sort Even Odd Index Independently", back: "Extract even/odd, sort separately, merge back." },
    { front: "Custom Sort String", back: "Sort by position in order string." },
    { front: "Relative Sort Array", back: "Count sort based on order array." },
    { front: "Sort Integers by Power Value", back: "Compute power values, sort by them." },
    { front: "Maximum Units on a Truck", back: "Greedy: sort by units, take highest first." },
    { front: "Reduce Array Size to Half", back: "Count frequencies, sort desc, take top until half." },
    { front: "Minimum Absolute Difference", back: "Sort, find minimum adjacent difference." },
    { front: "Minimum Time Difference", back: "Sort times, check adjacent diffs including circular." },
    { front: "Reorder Data in Log Files", back: "Separate letter and digit logs, sort letters." },
    { front: "Array Partition I", back: "Sort, sum every other element. Greedy optimal." },
    { front: "Minimum Number of Arrows to Burst Balloons", back: "Sort by end, count non-overlapping." },
    { front: "Task Scheduler", back: "Count max frequency, calculate idle slots. O(n)." },
    { front: "Minimum Increment to Make Array Unique", back: "Sort, increment to make strictly increasing." },
    { front: "Boats to Save People", back: "Sort, two pointers: pair heaviest with lightest if possible." },
    { front: "Advantage Shuffle", back: "Sort both, assign smallest greater, or smallest overall." },
    { front: "Find K Closest Elements", back: "Binary search for left bound, or two pointers from median." },
    { front: "Compare Version Numbers", back: "Split by dot, compare integers." },
    { front: "Sort Characters By Frequency", back: "Count, sort by frequency, build string." },
    { front: "Frequency Sort", back: "Sort by frequency, then by value." },
    { front: "Top K Frequent Words", back: "Count + heap with custom comparator." },
];
