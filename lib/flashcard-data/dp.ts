// Dynamic Programming - 25 Detailed Flashcards
export const DP_CARDS = [
    { front: "What is Dynamic Programming and when should you use it?", back: "**Dynamic Programming (DP):** Solving complex problems by breaking them into overlapping subproblems and storing results.\n\n**When to use:**\n1. **Optimal Substructure:** Solution contains optimal subproblem solutions\n2. **Overlapping Subproblems:** Same subproblems solved repeatedly\n\n**Two Approaches:**\n- **Top-Down (Memoization):** Recursion + cache\n- **Bottom-Up (Tabulation):** Iterative from base cases\n\n**Common Patterns:** 0/1 Knapsack, LCS, LIS, Partition problems" },
    { front: "How do you solve the Climbing Stairs problem?", back: "**Problem:** How many ways to climb n stairs taking 1 or 2 steps?\n\n**Recurrence:** `dp[i] = dp[i-1] + dp[i-2]` (Fibonacci!)\n\n```python\ndef climbStairs(n):\n    if n <= 2: return n\n    prev2, prev1 = 1, 2\n    for i in range(3, n + 1):\n        current = prev1 + prev2\n        prev2, prev1 = prev1, current\n    return prev1\n```\n\n**O(n) time, O(1) space**" },
    { front: "Explain the 0/1 Knapsack problem and solution.", back: "**Problem:** Maximize value in knapsack of capacity W. Each item used once.\n\n**Recurrence:**\n```\ndp[i][w] = max(dp[i-1][w], dp[i-1][w-wt[i]] + val[i])\n```\n\n```python\ndef knapsack(weights, values, W):\n    dp = [0] * (W + 1)\n    for i in range(len(weights)):\n        for w in range(W, weights[i] - 1, -1):  # Backwards!\n            dp[w] = max(dp[w], dp[w - weights[i]] + values[i])\n    return dp[W]\n```\n\n**O(n×W) time, O(W) space**" },
    { front: "How do you find the Longest Common Subsequence (LCS)?", back: "**Problem:** Find longest subsequence common to both strings.\n\n**Recurrence:**\n```\nif s1[i] == s2[j]: dp[i][j] = dp[i-1][j-1] + 1\nelse: dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n```\n\n```python\ndef lcs(text1, text2):\n    m, n = len(text1), len(text2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if text1[i-1] == text2[j-1]:\n                dp[i][j] = dp[i-1][j-1] + 1\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1])\n    return dp[m][n]\n```\n\n**O(m×n) time and space**" },
    { front: "How do you find the Longest Increasing Subsequence in O(n log n)?", back: "**O(n log n) Solution using Binary Search:**\n\n```python\ndef lengthOfLIS(nums):\n    tails = []  # tails[i] = smallest ending of LIS of length i+1\n    for num in nums:\n        pos = bisect_left(tails, num)\n        if pos == len(tails):\n            tails.append(num)\n        else:\n            tails[pos] = num\n    return len(tails)\n```\n\n**Example:** [10, 9, 2, 5, 3, 7, 101]\n- tails evolves: [10] → [9] → [2] → [2,5] → [2,3] → [2,3,7] → [2,3,7,101]\n- Answer: 4" },
    { front: "How do you solve the Edit Distance problem?", back: "**Problem:** Min operations (insert, delete, replace) to convert word1 to word2.\n\n```python\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    \n    for i in range(m+1): dp[i][0] = i\n    for j in range(n+1): dp[0][j] = j\n    \n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]\n            else:\n                dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n    return dp[m][n]\n```\n\n**Example:** \"horse\" → \"ros\" = 3" },
    { front: "How do you solve the Coin Change problem (minimum coins)?", back: "**Recurrence:** `dp[i] = min(dp[i], dp[i - coin] + 1)`\n\n```python\ndef coinChange(coins, amount):\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0\n    for i in range(1, amount + 1):\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    return dp[amount] if dp[amount] != float('inf') else -1\n```\n\n**Why greedy fails:** coins [1,3,4], amount 6\n- Greedy: 4+1+1 = 3 coins\n- Optimal: 3+3 = 2 coins" },
    { front: "How do you solve the House Robber problem?", back: "**Problem:** Rob houses, can't rob adjacent. Maximize loot.\n\n**Recurrence:** `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`\n\n```python\ndef rob(nums):\n    if len(nums) <= 2: return max(nums) if nums else 0\n    prev2, prev1 = nums[0], max(nums[0], nums[1])\n    for i in range(2, len(nums)):\n        current = max(prev1, prev2 + nums[i])\n        prev2, prev1 = prev1, current\n    return prev1\n```\n\n**House Robber II (circular):** Run twice excluding first or last house." },
    { front: "How do you solve the Word Break problem?", back: "**Recurrence:** `dp[i] = True if dp[j] AND s[j:i] in dict`\n\n```python\ndef wordBreak(s, wordDict):\n    word_set = set(wordDict)\n    dp = [False] * (len(s) + 1)\n    dp[0] = True\n    for i in range(1, len(s) + 1):\n        for j in range(i):\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break\n    return dp[len(s)]\n```\n\n**Example:** \"leetcode\", [\"leet\", \"code\"] → True" },
    { front: "How do you find the Minimum Path Sum in a grid?", back: "**Recurrence:** `dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])`\n\n```python\ndef minPathSum(grid):\n    m, n = len(grid), len(grid[0])\n    for j in range(1, n): grid[0][j] += grid[0][j-1]\n    for i in range(1, m): grid[i][0] += grid[i-1][0]\n    for i in range(1, m):\n        for j in range(1, n):\n            grid[i][j] += min(grid[i-1][j], grid[i][j-1])\n    return grid[m-1][n-1]\n```\n\n**O(m×n) time, O(1) space (modifying input)**" },
    { front: "How do you find the Maximal Square in a binary matrix?", back: "**Recurrence:** If matrix[i][j] == 1:\n`dp[i][j] = min(left, top, diagonal) + 1`\n\n```python\ndef maximalSquare(matrix):\n    m, n = len(matrix), len(matrix[0])\n    dp = [[0] * (n+1) for _ in range(m+1)]\n    max_side = 0\n    for i in range(1, m+1):\n        for j in range(1, n+1):\n            if matrix[i-1][j-1] == '1':\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n                max_side = max(max_side, dp[i][j])\n    return max_side * max_side\n```" },
    { front: "How do you solve the Partition Equal Subset Sum problem?", back: "**Key Insight:** Find subset with sum = totalSum/2 → 0/1 Knapsack!\n\n```python\ndef canPartition(nums):\n    total = sum(nums)\n    if total % 2: return False\n    \n    target = total // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    \n    for num in nums:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    \n    return dp[target]\n```\n\n**Example:** [1, 5, 11, 5] → [1,5,5] and [11] both sum to 11" },
    { front: "How do you count ways to make change (Coin Change II)?", back: "**Combinations (order doesn't matter):**\n\n```python\ndef change(amount, coins):\n    dp = [0] * (amount + 1)\n    dp[0] = 1\n    for coin in coins:  # Outer loop on coins!\n        for j in range(coin, amount + 1):\n            dp[j] += dp[j - coin]\n    return dp[amount]\n```\n\n**Why outer loop on coins?** Avoids counting [1,2] and [2,1] separately.\n\n**Example:** coins=[1,2,5], amount=5 → 4 ways" },
    { front: "How do you solve the Perfect Squares problem?", back: "**Recurrence:** `dp[n] = min(dp[n - i²] + 1)` for all i² ≤ n\n\n```python\ndef numSquares(n):\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0\n    for i in range(1, n + 1):\n        j = 1\n        while j * j <= i:\n            dp[i] = min(dp[i], dp[i - j*j] + 1)\n            j += 1\n    return dp[n]\n```\n\n**Example:** n = 12 → 4 + 4 + 4 = 3 squares (not 9+1+1+1)" },
    { front: "How do you solve the Maximum Product Subarray?", back: "**Challenge:** Negative × negative = positive! Track both max and min.\n\n```python\ndef maxProduct(nums):\n    max_prod = min_prod = result = nums[0]\n    for i in range(1, len(nums)):\n        if nums[i] < 0:\n            max_prod, min_prod = min_prod, max_prod\n        max_prod = max(nums[i], nums[i] * max_prod)\n        min_prod = min(nums[i], nums[i] * min_prod)\n        result = max(result, max_prod)\n    return result\n```\n\n**Example:** [-2, 3, -4] → 24 (entire array)" },
    { front: "How do you solve the Best Time to Buy and Sell Stock with Cooldown?", back: "**States:** hold, sold, rest\n\n```python\ndef maxProfit(prices):\n    if len(prices) < 2: return 0\n    hold, sold, rest = -prices[0], 0, 0\n    for price in prices[1:]:\n        prev_hold = hold\n        hold = max(hold, rest - price)\n        rest = max(rest, sold)\n        sold = prev_hold + price\n    return max(sold, rest)\n```\n\n**Transitions:**\n- hold = keep OR buy from rest\n- sold = sell from hold\n- rest = stay OR cooldown from sold" },
    { front: "How do you solve the Decode Ways problem?", back: "**Recurrence:**\n- Add dp[i-1] if single digit valid (1-9)\n- Add dp[i-2] if two digits valid (10-26)\n\n```python\ndef numDecodings(s):\n    if not s or s[0] == '0': return 0\n    dp = [0] * (len(s) + 1)\n    dp[0], dp[1] = 1, 1\n    for i in range(2, len(s) + 1):\n        if s[i-1] != '0':\n            dp[i] += dp[i-1]\n        if 10 <= int(s[i-2:i]) <= 26:\n            dp[i] += dp[i-2]\n    return dp[len(s)]\n```\n\n**Example:** \"226\" → 3 ways (BBF, VF, BZ)" },
    { front: "How do you find the Longest Palindromic Subsequence?", back: "**Key Insight:** LPS(s) = LCS(s, reverse(s))\n\n```python\ndef longestPalindromeSubseq(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n): dp[i][i] = 1\n    \n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    return dp[0][n-1]\n```\n\n**Example:** \"bbbab\" → \"bbbb\" = 4" },
    { front: "How do you solve unique paths in a grid?", back: "**Recurrence:** `dp[i][j] = dp[i-1][j] + dp[i][j-1]`\n\n```python\ndef uniquePaths(m, n):\n    dp = [1] * n\n    for i in range(1, m):\n        for j in range(1, n):\n            dp[j] += dp[j-1]\n    return dp[n-1]\n```\n\n**O(m×n) time, O(n) space**\n\n**Math:** C(m+n-2, m-1) = (m+n-2)! / ((m-1)! × (n-1)!)" },
    { front: "How do you solve the Longest Valid Parentheses problem?", back: "**DP Solution:**\n\n```python\ndef longestValidParentheses(s):\n    dp = [0] * len(s)\n    max_len = 0\n    for i in range(1, len(s)):\n        if s[i] == ')':\n            if s[i-1] == '(':\n                dp[i] = (dp[i-2] if i >= 2 else 0) + 2\n            elif dp[i-1] > 0:\n                j = i - dp[i-1] - 1\n                if j >= 0 and s[j] == '(':\n                    dp[i] = dp[i-1] + 2 + (dp[j-1] if j >= 1 else 0)\n            max_len = max(max_len, dp[i])\n    return max_len\n```\n\n**Example:** \")()())\" → 4" },
];
