// Arrays & Strings - 100 Flashcards with Descriptive Content
export const ARRAYS_CARDS = [
    { front: "What is the time complexity of accessing an element in an array by its index?", back: "**O(1) - Constant Time**\n\nArrays provide direct access to elements using index calculation: base_address + (index × element_size). This makes random access extremely fast, which is one of the main advantages of arrays over linked lists." },
    { front: "How would you solve the Two Sum problem: 'Given an array of integers and a target, find two numbers that add up to the target'?", back: "**Use a HashMap for O(n) Solution**\n\n1. Create an empty HashMap\n2. For each number in array:\n   - Calculate complement = target - current_number\n   - If complement exists in HashMap, return both indices\n   - Otherwise, store current_number and its index\n\nThis gives O(n) time and O(n) space, much better than the O(n²) brute force approach." },
    { front: "What is the Sliding Window technique and when should you use it?", back: "**Sliding Window: Maintaining a 'window' of elements as you traverse**\n\nUse it when you need to find:\n- Maximum/minimum sum of k consecutive elements\n- Longest substring with certain properties\n- Subarray meeting specific conditions\n\n**How it works:**\n1. Start with a window (two pointers: left and right)\n2. Expand right to include new elements\n3. Shrink left when condition violated\n4. Track the best answer found\n\nConverts O(n²) brute force to O(n)." },
    { front: "How do you reverse a string in-place without using extra space?", back: "**Two-Pointer Technique**\n\n```\nleft = 0, right = length - 1\nwhile left < right:\n    swap(str[left], str[right])\n    left++, right--\n```\n\n**Complexity:**\n- Time: O(n) - visit each character once\n- Space: O(1) - only using two pointers\n\nThis works because swapping elements from both ends moves toward the center, eventually reversing the entire string." },
    { front: "Explain Kadane's Algorithm for finding the maximum subarray sum.", back: "**Kadane's Algorithm: O(n) solution for Maximum Subarray Sum**\n\n**Core Idea:** At each position, decide whether to:\n1. Extend the previous subarray, OR\n2. Start a new subarray from current element\n\n```\nmax_sum = current_sum = arr[0]\nfor i from 1 to n-1:\n    current_sum = max(arr[i], current_sum + arr[i])\n    max_sum = max(max_sum, current_sum)\nreturn max_sum\n```\n\n**Why it works:** If current_sum becomes negative, starting fresh is always better than carrying forward a negative sum." },
    { front: "What are the different approaches to find duplicate elements in an array?", back: "**Multiple Approaches Based on Constraints:**\n\n1. **HashSet - O(n) time, O(n) space**\n   - Add elements to set; if already exists, it's a duplicate\n\n2. **Sorting - O(n log n) time, O(1) space**\n   - Sort array, duplicates will be adjacent\n\n3. **If values are 0 to n-1 - O(n) time, O(1) space**\n   - Mark visited by negating value at index\n   - If already negative, it's a duplicate\n\n4. **Floyd's Cycle Detection - O(n) time, O(1) space**\n   - Treat values as pointers, find cycle" },
    { front: "Explain the Dutch National Flag algorithm for sorting an array of 0s, 1s, and 2s.", back: "**Dutch National Flag: Three-Way Partitioning in O(n)**\n\n**Use three pointers:**\n- `low` = 0 (boundary for 0s)\n- `mid` = 0 (current element)\n- `high` = n-1 (boundary for 2s)\n\n**Algorithm:**\n```\nwhile mid <= high:\n    if arr[mid] == 0:\n        swap(arr[low], arr[mid])\n        low++, mid++\n    elif arr[mid] == 1:\n        mid++\n    else:  # arr[mid] == 2\n        swap(arr[mid], arr[high])\n        high--\n```\n\n**Result:** 0s on left, 1s in middle, 2s on right. Single pass, O(1) space." },
    { front: "How can you rotate an array by k positions to the right efficiently?", back: "**Three-Reverse Method: O(n) time, O(1) space**\n\nFor array [1,2,3,4,5] rotated by k=2:\n\n1. **Reverse entire array:** [5,4,3,2,1]\n2. **Reverse first k elements:** [4,5,3,2,1]\n3. **Reverse remaining n-k elements:** [4,5,1,2,3] ✓\n\n**Important:** Handle k = k % n to avoid unnecessary rotations.\n\n**Why it works:** Reversing twice with the right split points effectively rotates the elements to their final positions." },
    { front: "How do you find the missing number in an array containing n distinct numbers from 0 to n?", back: "**Two Elegant Solutions:**\n\n**1. Sum Formula - O(n) time, O(1) space**\n```\nexpected_sum = n * (n + 1) / 2\nactual_sum = sum of all elements\nmissing = expected_sum - actual_sum\n```\n\n**2. XOR Method - O(n) time, O(1) space**\n```\nresult = n  # XOR with all indices\nfor i from 0 to n-1:\n    result ^= i ^ arr[i]\nreturn result\n```\n\n**Why XOR works:** a ^ a = 0, so all pairs cancel out, leaving only the missing number." },
    { front: "How do you remove duplicates from a sorted array in-place and return the new length?", back: "**Two-Pointer Approach: O(n) time, O(1) space**\n\n```\nif array is empty: return 0\n\nslow = 0  # Position for next unique element\nfor fast from 1 to n-1:\n    if arr[fast] != arr[slow]:\n        slow++\n        arr[slow] = arr[fast]\n\nreturn slow + 1  # Length of unique elements\n```\n\n**Example:** [1,1,2,2,3] → [1,2,3,_,_], returns 3\n\n**Key Insight:** Since array is sorted, duplicates are adjacent. The slow pointer marks where to place the next unique element." },
    { front: "What is the Container With Most Water problem and how do you solve it?", back: "**Problem:** Given array of heights, find two lines that together with x-axis forms a container holding the most water.\n\n**Two-Pointer Solution: O(n) time**\n\n```\nleft = 0, right = n-1\nmax_water = 0\n\nwhile left < right:\n    width = right - left\n    height = min(arr[left], arr[right])\n    max_water = max(max_water, width * height)\n    \n    # Move the shorter line inward\n    if arr[left] < arr[right]:\n        left++\n    else:\n        right--\n```\n\n**Why move the shorter line?** Water is limited by the shorter line. Moving it might find a taller line and increase area." },
    { front: "How do you solve the 3Sum problem to find all unique triplets that sum to zero?", back: "**Sort + Two Pointers: O(n²) time**\n\n```\nsort(array)\nresult = []\n\nfor i from 0 to n-3:\n    # Skip duplicates for first element\n    if i > 0 and arr[i] == arr[i-1]: continue\n    \n    left = i + 1\n    right = n - 1\n    \n    while left < right:\n        total = arr[i] + arr[left] + arr[right]\n        if total == 0:\n            result.add([arr[i], arr[left], arr[right]])\n            # Skip duplicates\n            while left < right and arr[left] == arr[left+1]: left++\n            while left < right and arr[right] == arr[right-1]: right--\n            left++, right--\n        elif total < 0:\n            left++\n        else:\n            right--\n```" },
    { front: "Explain the Trapping Rain Water problem and its solution.", back: "**Problem:** Given elevation map, calculate how much water can be trapped after rain.\n\n**Key Insight:** Water at position i = min(leftMax, rightMax) - height[i]\n\n**Two-Pointer Solution: O(n) time, O(1) space**\n\n```\nleft = 0, right = n-1\nleftMax = rightMax = 0\nwater = 0\n\nwhile left < right:\n    if height[left] < height[right]:\n        if height[left] >= leftMax:\n            leftMax = height[left]\n        else:\n            water += leftMax - height[left]\n        left++\n    else:\n        if height[right] >= rightMax:\n            rightMax = height[right]\n        else:\n            water += rightMax - height[right]\n        right--\n```\n\n**Alternative:** Use prefix arrays for leftMax and rightMax - O(n) space." },
    { front: "How do you find the longest consecutive sequence in an unsorted array in O(n) time?", back: "**HashSet Solution: O(n) time, O(n) space**\n\n```\nCreate HashSet from array\nmax_length = 0\n\nfor num in set:\n    # Only start counting from sequence beginning\n    if (num - 1) not in set:\n        current = num\n        length = 1\n        \n        while (current + 1) in set:\n            current++\n            length++\n        \n        max_length = max(max_length, length)\n\nreturn max_length\n```\n\n**Why O(n)?** Each number is visited at most twice - once in the outer loop, once when extending a sequence.\n\n**Example:** [100, 4, 200, 1, 3, 2] → Longest is [1,2,3,4] = 4" },
    { front: "What is the First Missing Positive problem and how do you solve it in O(n) time and O(1) space?", back: "**Problem:** Find the smallest missing positive integer.\n\n**Key Insight:** Answer must be in range [1, n+1]. Use array itself as hash table!\n\n```\n# Step 1: Place each number at its correct index\nfor i from 0 to n-1:\n    while 1 <= arr[i] <= n and arr[arr[i]-1] != arr[i]:\n        swap(arr[i], arr[arr[i]-1])\n\n# Step 2: Find first mismatch\nfor i from 0 to n-1:\n    if arr[i] != i + 1:\n        return i + 1\n\nreturn n + 1\n```\n\n**Example:** [3,4,-1,1] → After placing: [1,-1,3,4] → Missing: 2" },
    { front: "How do you find the maximum sum of a subarray of size k (fixed window)?", back: "**Fixed-Size Sliding Window: O(n) time**\n\n```\n# Initialize: sum of first k elements\nwindow_sum = sum(arr[0:k])\nmax_sum = window_sum\n\n# Slide the window\nfor i from k to n-1:\n    window_sum += arr[i] - arr[i-k]  # Add new, remove old\n    max_sum = max(max_sum, window_sum)\n\nreturn max_sum\n```\n\n**Why O(n)?** Instead of calculating sum of k elements each time (O(n×k)), we maintain a running sum by adding the new element and subtracting the element that left the window.\n\n**Example:** [1,4,2,10,2,3,1,0,20], k=4\nMax sum = 24 (subarray [2,3,1,0,20]... wait, let me recalculate: [10,2,3,1]=16... [0,20]=... Actually [2,10,2,3]=17)" },
    { front: "How do you find the longest substring without repeating characters?", back: "**Variable-Size Sliding Window: O(n) time**\n\n```\nleft = 0\nmax_length = 0\nchar_index = {}  # Store last index of each character\n\nfor right from 0 to n-1:\n    char = s[right]\n    \n    # If char seen and within current window\n    if char in char_index and char_index[char] >= left:\n        left = char_index[char] + 1  # Shrink window\n    \n    char_index[char] = right\n    max_length = max(max_length, right - left + 1)\n\nreturn max_length\n```\n\n**Example:** \"abcabcbb\"\n- Window expands: a, ab, abc\n- Sees 'a' again: window becomes bca\n- Maximum: 3 (\"abc\")" },
    { front: "How do you check if two strings are anagrams of each other?", back: "**Two Approaches:**\n\n**1. Sorting - O(n log n) time, O(1) space**\n```\nreturn sorted(s1) == sorted(s2)\n```\n\n**2. Character Counting - O(n) time, O(1) space**\n```\nif len(s1) != len(s2): return False\n\ncount = array of 26 zeros\n\nfor i from 0 to n-1:\n    count[s1[i] - 'a']++\n    count[s2[i] - 'a']--\n\nreturn all counts are zero\n```\n\n**Why O(1) space?** Only 26 letters in alphabet, fixed size.\n\n**Example:** \"listen\" and \"silent\" → Both have: e(1), i(1), l(1), n(1), s(1), t(1) ✓" },
    { front: "How do you group anagrams together from a list of strings?", back: "**HashMap with Sorted Key: O(n × k log k)**\n\nwhere n = number of strings, k = max string length\n\n```\ngroups = HashMap<String, List<String>>\n\nfor word in words:\n    key = sort(word)  # \"eat\" → \"aet\"\n    groups[key].append(word)\n\nreturn groups.values()\n```\n\n**Alternative: Character Count Key - O(n × k)**\n```\nkey = count of each character\n# \"eat\" → \"1a1e1t\" or tuple (1,0,0,0,1,0,...,1)\n```\n\n**Example:**\nInput: [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"eat\",\"tea\",\"ate\"],[\"tan\",\"nat\"],[\"bat\"]]" },
    { front: "How do you find the longest palindromic substring in a string?", back: "**Expand Around Center: O(n²) time, O(1) space**\n\n```\ndef expandAroundCenter(s, left, right):\n    while left >= 0 and right < len(s) and s[left] == s[right]:\n        left--, right++\n    return right - left - 1\n\nstart = 0\nmax_len = 1\n\nfor i from 0 to n-1:\n    # Odd length palindromes (single center)\n    len1 = expandAroundCenter(s, i, i)\n    # Even length palindromes (two centers)\n    len2 = expandAroundCenter(s, i, i+1)\n    \n    if max(len1, len2) > max_len:\n        max_len = max(len1, len2)\n        start = i - (max_len - 1) / 2\n\nreturn s[start : start + max_len]\n```\n\n**Example:** \"babad\" → \"bab\" or \"aba\"" },
    { front: "How do you rotate a 2D matrix (image) by 90 degrees clockwise in-place?", back: "**Two-Step Process: O(n²) time, O(1) space**\n\n**Step 1: Transpose (swap rows and columns)**\n```\nfor i from 0 to n-1:\n    for j from i+1 to n-1:\n        swap(matrix[i][j], matrix[j][i])\n```\n\n**Step 2: Reverse each row**\n```\nfor each row:\n    reverse(row)\n```\n\n**Example:**\n```\n[1,2,3]      [1,4,7]      [7,4,1]\n[4,5,6]  →   [2,5,8]  →   [8,5,2]\n[7,8,9]      [3,6,9]      [9,6,3]\n```\n\n**For counter-clockwise:** Transpose, then reverse each column (or reverse rows first, then transpose)." },
    { front: "How do you traverse a matrix in spiral order?", back: "**Boundary Tracking: O(m×n) time**\n\n```\nresult = []\ntop, bottom = 0, m-1\nleft, right = 0, n-1\n\nwhile top <= bottom and left <= right:\n    # Traverse right\n    for col from left to right:\n        result.append(matrix[top][col])\n    top++\n    \n    # Traverse down\n    for row from top to bottom:\n        result.append(matrix[row][right])\n    right--\n    \n    # Traverse left (if rows remaining)\n    if top <= bottom:\n        for col from right to left:\n            result.append(matrix[bottom][col])\n        bottom--\n    \n    # Traverse up (if cols remaining)\n    if left <= right:\n        for row from bottom to top:\n            result.append(matrix[row][left])\n        left++\n\nreturn result\n```" },
    { front: "How do you set entire row and column to zero if an element is zero in a matrix?", back: "**Use First Row/Column as Markers: O(mn) time, O(1) space**\n\n```\nfirstRowZero = any zero in first row\nfirstColZero = any zero in first column\n\n# Mark zeros in first row/column\nfor i from 1 to m-1:\n    for j from 1 to n-1:\n        if matrix[i][j] == 0:\n            matrix[i][0] = 0  # Mark row\n            matrix[0][j] = 0  # Mark column\n\n# Set zeros based on marks\nfor i from 1 to m-1:\n    for j from 1 to n-1:\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n            matrix[i][j] = 0\n\n# Handle first row and column\nif firstRowZero: set first row to zeros\nif firstColZero: set first column to zeros\n```" },
    { front: "How do you search for a target in a 2D matrix where rows and columns are sorted?", back: "**Start from Top-Right (or Bottom-Left): O(m+n) time**\n\n```\nrow = 0\ncol = n - 1  # Start from top-right\n\nwhile row < m and col >= 0:\n    if matrix[row][col] == target:\n        return True\n    elif matrix[row][col] > target:\n        col--  # Target is smaller, go left\n    else:\n        row++  # Target is larger, go down\n\nreturn False\n```\n\n**Why this works:**\n- Top-right element: largest in its row, smallest in its column\n- Each comparison eliminates a row OR a column\n\n**Alternative (if fully sorted):** Binary search treating as 1D array: O(log(m×n))" },
    { front: "How do you find the largest rectangle area in a histogram?", back: "**Monotonic Increasing Stack: O(n) time**\n\n```\nstack = []  # Store indices\nmax_area = 0\n\nfor i from 0 to n:  # Note: go to n for cleanup\n    h = heights[i] if i < n else 0\n    \n    while stack and heights[stack.top()] > h:\n        height = heights[stack.pop()]\n        width = i if stack.empty() else i - stack.top() - 1\n        max_area = max(max_area, height * width)\n    \n    stack.push(i)\n\nreturn max_area\n```\n\n**Key Insight:** For each bar, find how far it can extend left and right. The stack maintains bars in increasing height - when we see a shorter bar, we know the right boundary for taller bars." },
    { front: "How do you find the next permutation of a number/array?", back: "**Algorithm: O(n) time, O(1) space**\n\n```\n# Step 1: Find first decreasing element from right\ni = n - 2\nwhile i >= 0 and nums[i] >= nums[i+1]:\n    i--\n\nif i >= 0:\n    # Step 2: Find element just larger than nums[i]\n    j = n - 1\n    while nums[j] <= nums[i]:\n        j--\n    swap(nums[i], nums[j])\n\n# Step 3: Reverse suffix after position i\nreverse(nums, i+1, n-1)\n```\n\n**Example:** [1,2,3] → [1,3,2] → [2,1,3] → [2,3,1] → [3,1,2] → [3,2,1] → [1,2,3]\n\n**Why it works:** We find the rightmost element that can be incremented, swap with the smallest larger element to its right, then sort the suffix." },
    { front: "How does the Best Time to Buy and Sell Stock problem work (one transaction)?", back: "**Track Minimum Price: O(n) time, O(1) space**\n\n```\nmin_price = infinity\nmax_profit = 0\n\nfor price in prices:\n    min_price = min(min_price, price)\n    max_profit = max(max_profit, price - min_price)\n\nreturn max_profit\n```\n\n**Why it works:**\n- At each day, we know the minimum price seen so far\n- If we sold today, profit = today's price - min_price so far\n- Track the maximum profit across all days\n\n**Example:** [7,1,5,3,6,4]\n- Min prices: 7,1,1,1,1,1\n- If sold each day: 0,0,4,2,5,3\n- Max profit: 5 (buy at 1, sell at 6)" },
    { front: "How do you calculate the product of an array except self without using division?", back: "**Two-Pass Approach: O(n) time, O(1) extra space**\n\n```\nn = len(nums)\nresult = [1] * n\n\n# Left pass: result[i] = product of all elements left of i\nleft_product = 1\nfor i from 0 to n-1:\n    result[i] = left_product\n    left_product *= nums[i]\n\n# Right pass: multiply by product of all elements right of i\nright_product = 1\nfor i from n-1 to 0:\n    result[i] *= right_product\n    right_product *= nums[i]\n\nreturn result\n```\n\n**Example:** [1,2,3,4]\n- After left pass: [1, 1, 2, 6]\n- After right pass: [24, 12, 8, 6] ✓\n\nEach result[i] = (product of left elements) × (product of right elements)" },
    { front: "How do you solve the Jump Game problem (can you reach the end)?", back: "**Greedy Approach: O(n) time, O(1) space**\n\n```\nmax_reachable = 0\n\nfor i from 0 to n-1:\n    # Can't reach this position\n    if i > max_reachable:\n        return False\n    \n    # Update furthest reachable position\n    max_reachable = max(max_reachable, i + nums[i])\n    \n    # Can reach or pass the end\n    if max_reachable >= n - 1:\n        return True\n\nreturn True  # Reached the end\n```\n\n**Example:** [2,3,1,1,4]\n- i=0: max_reachable = 2\n- i=1: max_reachable = max(2, 1+3) = 4 ≥ 4 ✓ Can reach end!\n\n**Example:** [3,2,1,0,4] → Gets stuck at index 3 (all zeros)" },
    { front: "How do you merge overlapping intervals?", back: "**Sort + Merge: O(n log n) time**\n\n```\n# Sort by start time\nintervals.sort(key=lambda x: x[0])\n\nmerged = [intervals[0]]\n\nfor current in intervals[1:]:\n    last = merged[-1]\n    \n    if current[0] <= last[1]:  # Overlapping\n        last[1] = max(last[1], current[1])  # Extend end\n    else:\n        merged.append(current)  # No overlap, add new\n\nreturn merged\n```\n\n**Example:**\nInput: [[1,3],[2,6],[8,10],[15,18]]\n- [1,3] and [2,6] overlap → [1,6]\n- [8,10] doesn't overlap with [1,6]\n- [15,18] doesn't overlap with [8,10]\nOutput: [[1,6],[8,10],[15,18]]" },
    { front: "What is the Majority Element problem and how do you solve it in O(1) space?", back: "**Boyer-Moore Voting Algorithm: O(n) time, O(1) space**\n\n```\ncandidate = None\ncount = 0\n\nfor num in nums:\n    if count == 0:\n        candidate = num\n    count += 1 if num == candidate else -1\n\nreturn candidate  # (verify if majority not guaranteed)\n```\n\n**Why it works:**\n- Majority element appears > n/2 times\n- Pair each majority element with a non-majority element\n- Some majority elements will be unpaired → they survive!\n\n**Example:** [2,2,1,1,1,2,2]\n- Candidate: 2 (count=1) → 2 (2) → 1 (1) → 1 (0) → 1 (1) → 2 (0) → 2 (1)\n- Result: 2 ✓ (appears 4 times out of 7)" },
    { front: "How do you find the minimum in a rotated sorted array?", back: "**Binary Search: O(log n) time**\n\n```\nleft, right = 0, n - 1\n\nwhile left < right:\n    mid = (left + right) // 2\n    \n    if nums[mid] > nums[right]:\n        # Minimum is in right half\n        left = mid + 1\n    else:\n        # Minimum is in left half (including mid)\n        right = mid\n\nreturn nums[left]\n```\n\n**Why compare with right?**\n- If mid > right: rotation point is between mid and right\n- If mid ≤ right: this half is sorted, minimum is at or before mid\n\n**Example:** [4,5,6,7,0,1,2]\n- mid=3 (value 7) > right=2 → search right [0,1,2]\n- mid=1 (value 0) ≤ right=2 → search left [0]\n- Found: 0" },
    { front: "How do you search for a target in a rotated sorted array?", back: "**Modified Binary Search: O(log n) time**\n\n```\nleft, right = 0, n - 1\n\nwhile left <= right:\n    mid = (left + right) // 2\n    \n    if nums[mid] == target:\n        return mid\n    \n    # Left half is sorted\n    if nums[left] <= nums[mid]:\n        if nums[left] <= target < nums[mid]:\n            right = mid - 1  # Target in left half\n        else:\n            left = mid + 1   # Target in right half\n    # Right half is sorted\n    else:\n        if nums[mid] < target <= nums[right]:\n            left = mid + 1   # Target in right half\n        else:\n            right = mid - 1  # Target in left half\n\nreturn -1\n```\n\n**Key Insight:** One half is always sorted. Check if target is in the sorted half." },
    { front: "How do you find the median of two sorted arrays in O(log(min(m,n))) time?", back: "**Binary Search on Partition: O(log(min(m,n)))**\n\n```\n# Always search on smaller array\nif len(nums1) > len(nums2):\n    nums1, nums2 = nums2, nums1\n\nm, n = len(nums1), len(nums2)\nlow, high = 0, m\n\nwhile low <= high:\n    partX = (low + high) // 2\n    partY = (m + n + 1) // 2 - partX\n    \n    maxLeftX = -∞ if partX == 0 else nums1[partX-1]\n    minRightX = ∞ if partX == m else nums1[partX]\n    maxLeftY = -∞ if partY == 0 else nums2[partY-1]\n    minRightY = ∞ if partY == n else nums2[partY]\n    \n    if maxLeftX <= minRightY and maxLeftY <= minRightX:\n        # Found correct partition\n        if (m + n) % 2 == 0:\n            return (max(maxLeftX, maxLeftY) + min(minRightX, minRightY)) / 2\n        else:\n            return max(maxLeftX, maxLeftY)\n    elif maxLeftX > minRightY:\n        high = partX - 1\n    else:\n        low = partX + 1\n```" },
    { front: "How do you solve the Meeting Rooms II problem (minimum meeting rooms required)?", back: "**Sort + Min-Heap: O(n log n) time**\n\n```\nif not intervals: return 0\n\n# Sort by start time\nintervals.sort(key=lambda x: x[0])\n\n# Min-heap to track end times of ongoing meetings\nheap = []\nheappush(heap, intervals[0][1])  # End time of first meeting\n\nfor i from 1 to n-1:\n    start, end = intervals[i]\n    \n    # If earliest ending meeting ends before this starts\n    if heap[0] <= start:\n        heappop(heap)  # Reuse that room\n    \n    heappush(heap, end)  # Add new meeting's end time\n\nreturn len(heap)  # Heap size = rooms needed\n```\n\n**Example:** [[0,30],[5,10],[15,20]]\n- Meeting 1: heap = [30]\n- Meeting 2: 5 < 30, can't reuse → heap = [10, 30]\n- Meeting 3: 15 >= 10, reuse room → heap = [20, 30]\n- Answer: 2 rooms" },
    { front: "How do you find the maximum circular subarray sum?", back: "**Two Cases: O(n) time, O(1) space**\n\n**Case 1:** Max subarray doesn't wrap around → Standard Kadane's\n\n**Case 2:** Max subarray wraps around → Total Sum - Min Subarray Sum\n\n```\nmax_sum = kadane(arr)      # Case 1\nmin_sum = kadane_min(arr)  # Find minimum subarray\ntotal = sum(arr)\n\n# Case 2: wrap around = total - min (the part we exclude)\nwrap_sum = total - min_sum\n\n# Handle edge case: all negative numbers\nif wrap_sum == 0:  # All elements in min_subarray\n    return max_sum\n\nreturn max(max_sum, wrap_sum)\n```\n\n**Example:** [5, -3, 5] \n- Regular Kadane: 7 (5 + (-3) + 5)\n- Wrapped: 5 + 5 = 10 (exclude -3) ✓" },
    { front: "How do you implement a solution for the Task Scheduler problem?", back: "**Calculate Idle Slots: O(n) time**\n\n**Problem:** Given tasks and cooldown n, find minimum time to complete all.\n\n```\n# Count frequencies\nfreq = count frequency of each task\nmax_freq = max(freq.values())\n\n# Count how many tasks have max frequency\nmax_count = count tasks with max_freq\n\n# Calculate result\n# Minimum slots = (max_freq - 1) × (n + 1) + max_count\nresult = (max_freq - 1) * (n + 1) + max_count\n\n# But we need at least len(tasks) slots\nreturn max(result, len(tasks))\n```\n\n**Example:** tasks = [A,A,A,B,B,B], n = 2\n- max_freq = 3, max_count = 2 (both A and B)\n- result = (3-1) × (2+1) + 2 = 8\n- Schedule: A B _ A B _ A B or A B idle A B idle A B" },
    { front: "How do you find the shortest unsorted continuous subarray?", back: "**Two-Pointer Bounds: O(n) time, O(1) space**\n\n```\nn = len(nums)\nleft = 0\nright = n - 1\n\n# Find left boundary: first element out of order\nwhile left < n - 1 and nums[left] <= nums[left + 1]:\n    left++\n\nif left == n - 1:  # Already sorted\n    return 0\n\n# Find right boundary: first element out of order from right\nwhile right > 0 and nums[right] >= nums[right - 1]:\n    right--\n\n# Find min and max in the unsorted portion\nsubarray_min = min(nums[left:right+1])\nsubarray_max = max(nums[left:right+1])\n\n# Extend boundaries if needed\nwhile left > 0 and nums[left - 1] > subarray_min:\n    left--\nwhile right < n - 1 and nums[right + 1] < subarray_max:\n    right++\n\nreturn right - left + 1\n```\n\n**Example:** [2,6,4,8,10,9,15] → Subarray [6,4,8,10,9] of length 5 needs sorting." },
    { front: "How do you partition an array so that all elements less than k come before those greater?", back: "**Two-Pointer Partition (QuickSort Partition): O(n)**\n\n```\ndef partition(arr, pivot):\n    i = 0  # Position for next element < pivot\n    \n    for j from 0 to n-1:\n        if arr[j] < pivot:\n            swap(arr[i], arr[j])\n            i++\n    \n    return i  # All elements before i are < pivot\n```\n\n**Three-Way Partition (handling equals):**\n```\nlow = 0     # Elements < pivot\nmid = 0     # Current element\nhigh = n-1  # Elements > pivot\n\nwhile mid <= high:\n    if arr[mid] < pivot:\n        swap(arr[low], arr[mid])\n        low++, mid++\n    elif arr[mid] > pivot:\n        swap(arr[mid], arr[high])\n        high--\n    else:  # arr[mid] == pivot\n        mid++\n```" },
    { front: "How do you solve the Gas Station Circuit problem?", back: "**Greedy: O(n) time, O(1) space**\n\n**Problem:** Find starting station to complete full circuit.\n\n```\ntotal_gas = 0\ncurrent_gas = 0\nstart_station = 0\n\nfor i from 0 to n-1:\n    diff = gas[i] - cost[i]\n    total_gas += diff\n    current_gas += diff\n    \n    if current_gas < 0:\n        # Can't reach station i+1 from start_station\n        # Try starting from i+1\n        start_station = i + 1\n        current_gas = 0\n\n# If total gas >= total cost, solution exists\nreturn start_station if total_gas >= 0 else -1\n```\n\n**Key Insight:**\n1. If total gas ≥ total cost, solution always exists\n2. If we can't reach station j from station i, none of the stations between i and j can be the start either\n3. So we skip to j+1" },
    { front: "How do you find all subarray sums equal to a target k?", back: "**Prefix Sum + HashMap: O(n) time, O(n) space**\n\n```\ncount = 0\nprefix_sum = 0\nprefix_count = {0: 1}  # Sum 0 occurs once (empty prefix)\n\nfor num in nums:\n    prefix_sum += num\n    \n    # Check if there's a prefix that when removed gives sum k\n    # i.e., prefix_sum - k exists\n    if (prefix_sum - k) in prefix_count:\n        count += prefix_count[prefix_sum - k]\n    \n    # Add current prefix sum to map\n    prefix_count[prefix_sum] = prefix_count.get(prefix_sum, 0) + 1\n\nreturn count\n```\n\n**Why it works:**\n- Subarray sum from i to j = prefix[j] - prefix[i-1] = k\n- So prefix[j] - k = prefix[i-1]\n- We count how many valid i-1 positions exist\n\n**Example:** [1,1,1], k=2 → Subarrays [1,1] (indices 0-1) and [1,1] (indices 1-2) = 2" },
    { front: "How do you implement a Minimum Window Substring solution?", back: "**Variable Sliding Window: O(n) time**\n\n```\nfrom collections import Counter\n\nif not s or not t: return \"\"\n\nt_count = Counter(t)\nrequired = len(t_count)  # Unique chars needed\nformed = 0  # Unique chars in window with required frequency\n\nwindow = {}\nleft = right = 0\nmin_len = float('inf')\nresult = (0, 0)\n\nwhile right < len(s):\n    char = s[right]\n    window[char] = window.get(char, 0) + 1\n    \n    if char in t_count and window[char] == t_count[char]:\n        formed += 1\n    \n    # Contract window from left\n    while formed == required:\n        if right - left + 1 < min_len:\n            min_len = right - left + 1\n            result = (left, right)\n        \n        left_char = s[left]\n        window[left_char] -= 1\n        if left_char in t_count and window[left_char] < t_count[left_char]:\n            formed -= 1\n        left += 1\n    \n    right += 1\n\nreturn \"\" if min_len == float('inf') else s[result[0]:result[1]+1]\n```" },
    { front: "How do you solve Word Break: can a string be segmented into dictionary words?", back: "**Dynamic Programming: O(n²) time**\n\n```\ndef wordBreak(s, wordDict):\n    word_set = set(wordDict)\n    n = len(s)\n    \n    # dp[i] = True if s[0:i] can be segmented\n    dp = [False] * (n + 1)\n    dp[0] = True  # Empty string is valid\n    \n    for i from 1 to n:\n        for j from 0 to i-1:\n            # If s[0:j] is valid AND s[j:i] is in dictionary\n            if dp[j] and s[j:i] in word_set:\n                dp[i] = True\n                break  # Found valid segmentation for i\n    \n    return dp[n]\n```\n\n**Example:** s = \"leetcode\", wordDict = [\"leet\", \"code\"]\n- dp[4] = True (\"leet\" in dict)\n- dp[8] = dp[4] AND \"code\" in dict = True ✓\n\n**Optimization:** Check words by max length in dictionary to reduce inner loop iterations." },
    { front: "How do you solve the Edit Distance (Levenshtein Distance) problem?", back: "**Dynamic Programming: O(m×n) time and space**\n\n```\ndef minDistance(word1, word2):\n    m, n = len(word1), len(word2)\n    \n    # dp[i][j] = min operations to convert word1[0:i] to word2[0:j]\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Base cases: converting to/from empty string\n    for i in range(m + 1): dp[i][0] = i  # Delete all\n    for j in range(n + 1): dp[0][j] = j  # Insert all\n    \n    for i from 1 to m:\n        for j from 1 to n:\n            if word1[i-1] == word2[j-1]:\n                dp[i][j] = dp[i-1][j-1]  # No operation needed\n            else:\n                dp[i][j] = 1 + min(\n                    dp[i-1][j],    # Delete from word1\n                    dp[i][j-1],    # Insert into word1\n                    dp[i-1][j-1]   # Replace\n                )\n    \n    return dp[m][n]\n```\n\n**Example:** word1=\"horse\", word2=\"ros\"\nEdit distance = 3: horse → rorse → rose → ros" },
    { front: "How do you implement a solution for Valid Sudoku?", back: "**HashSet for Each Row, Column, and Box: O(81) time**\n\n```\ndef isValidSudoku(board):\n    rows = [set() for _ in range(9)]\n    cols = [set() for _ in range(9)]\n    boxes = [set() for _ in range(9)]  # 3x3 boxes\n    \n    for i in range(9):\n        for j in range(9):\n            num = board[i][j]\n            if num == '.': continue\n            \n            # Calculate box index\n            box_idx = (i // 3) * 3 + (j // 3)\n            \n            # Check for duplicates\n            if num in rows[i] or num in cols[j] or num in boxes[box_idx]:\n                return False\n            \n            rows[i].add(num)\n            cols[j].add(num)\n            boxes[box_idx].add(num)\n    \n    return True\n```\n\n**Box Index Formula:**\n- Boxes are numbered 0-8: top row (0,1,2), middle row (3,4,5), bottom row (6,7,8)\n- For cell (i,j): box = (i//3)*3 + (j//3)" },
    { front: "How do you find all permutations of an array?", back: "**Backtracking: O(n! × n) time**\n\n```\ndef permute(nums):\n    result = []\n    \n    def backtrack(start):\n        if start == len(nums):\n            result.append(nums[:])  # Add copy\n            return\n        \n        for i in range(start, len(nums)):\n            # Swap to fix element at position 'start'\n            nums[start], nums[i] = nums[i], nums[start]\n            \n            # Recurse for remaining positions\n            backtrack(start + 1)\n            \n            # Undo swap (backtrack)\n            nums[start], nums[i] = nums[i], nums[start]\n    \n    backtrack(0)\n    return result\n```\n\n**Example:** [1,2,3]\n- Fix 1 at start: [1,2,3], [1,3,2]\n- Fix 2 at start: [2,1,3], [2,3,1]\n- Fix 3 at start: [3,2,1], [3,1,2]\n\n**Time:** n! permutations × O(n) to copy each" },
    { front: "How do you generate all subsets (power set) of an array?", back: "**Two Approaches:**\n\n**1. Iterative (Cascading): O(n × 2^n)**\n```\ndef subsets(nums):\n    result = [[]]\n    \n    for num in nums:\n        # Add num to all existing subsets\n        result += [subset + [num] for subset in result]\n    \n    return result\n```\n\n**2. Backtracking:**\n```\ndef subsets(nums):\n    result = []\n    \n    def backtrack(start, current):\n        result.append(current[:])  # Add current subset\n        \n        for i in range(start, len(nums)):\n            current.append(nums[i])\n            backtrack(i + 1, current)\n            current.pop()  # Backtrack\n    \n    backtrack(0, [])\n    return result\n```\n\n**3. Bitmask: O(n × 2^n)**\n- For each number 0 to 2^n - 1, include nums[i] if bit i is set\n\n**Example:** [1,2] → [[], [1], [2], [1,2]]" },
    { front: "What is the difference between Combinations and Permutations in programming?", back: "**Combinations: Order doesn't matter**\n- \"Choose k elements from n\" → C(n,k) = n! / (k! × (n-k)!)\n- [1,2,3], k=2 → [1,2], [1,3], [2,3] (3 combinations)\n\n```\ndef combine(n, k):\n    result = []\n    def backtrack(start, current):\n        if len(current) == k:\n            result.append(current[:])\n            return\n        for i in range(start, n + 1):\n            current.append(i)\n            backtrack(i + 1, current)  # i+1: no revisiting\n            current.pop()\n    backtrack(1, [])\n    return result\n```\n\n**Permutations: Order matters**\n- \"Arrange k elements from n\" → P(n,k) = n! / (n-k)!\n- [1,2,3] → [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] (6 permutations)\n\n**Key Difference in Code:**\n- Combinations: `backtrack(i+1, ...)` - only consider later elements\n- Permutations: `backtrack(0, ...)` with used[] tracking - consider all unused elements" },
    { front: "How do you find the largest number that can be formed from an array of integers?", back: "**Custom Sorting: O(n log n) time**\n\n```\ndef largestNumber(nums):\n    # Convert to strings for comparison\n    strs = [str(num) for num in nums]\n    \n    # Custom comparator: compare a+b vs b+a\n    def compare(a, b):\n        if a + b > b + a:\n            return -1  # a should come first\n        elif a + b < b + a:\n            return 1  # b should come first\n        return 0\n    \n    # Sort with custom comparator\n    strs.sort(key=functools.cmp_to_key(compare))\n    \n    result = ''.join(strs)\n    \n    # Handle edge case: all zeros\n    return '0' if result[0] == '0' else result\n```\n\n**Example:** [3, 30, 34, 5, 9]\n- Compare \"3\" and \"30\": \"330\" > \"303\" → \"3\" first\n- Compare \"3\" and \"34\": \"334\" < \"343\" → \"34\" first\n- Sorted: [\"9\", \"5\", \"34\", \"3\", \"30\"]\n- Result: \"9534330\"" },
    { front: "How do you solve the Coin Change problem (minimum coins to make amount)?", back: "**Dynamic Programming: O(amount × coins) time**\n\n```\ndef coinChange(coins, amount):\n    # dp[i] = minimum coins needed to make amount i\n    dp = [float('inf')] * (amount + 1)\n    dp[0] = 0  # 0 coins needed for amount 0\n    \n    for i from 1 to amount:\n        for coin in coins:\n            if coin <= i and dp[i - coin] != float('inf'):\n                dp[i] = min(dp[i], dp[i - coin] + 1)\n    \n    return dp[amount] if dp[amount] != float('inf') else -1\n```\n\n**Example:** coins = [1, 2, 5], amount = 11\n- dp[5] = 1 (one 5-coin)\n- dp[10] = 2 (two 5-coins)\n- dp[11] = dp[6] + 1 = dp[1] + 1 + 1 = 3 (5+5+1)\n- Answer: 3 coins\n\n**Greedy doesn't work!** For coins [1,3,4], amount 6:\n- Greedy: 4+1+1 = 3 coins\n- Optimal: 3+3 = 2 coins" },
    { front: "How do you find the number of valid parentheses combinations for n pairs?", back: "**Backtracking with Constraints: O(4^n / √n) - Catalan number**\n\n```\ndef generateParenthesis(n):\n    result = []\n    \n    def backtrack(current, open_count, close_count):\n        if len(current) == 2 * n:\n            result.append(current)\n            return\n        \n        # Can add '(' if we haven't used all opens\n        if open_count < n:\n            backtrack(current + '(', open_count + 1, close_count)\n        \n        # Can add ')' if it won't make string invalid\n        if close_count < open_count:\n            backtrack(current + ')', open_count, close_count + 1)\n    \n    backtrack('', 0, 0)\n    return result\n```\n\n**Rules:**\n1. Can always add '(' if we have some left\n2. Can only add ')' if there's an unmatched '(' (close_count < open_count)\n\n**Example:** n = 3\nOutput: [\"((()))\", \"(()())\", \"(())()\", \"()(())\", \"()()()\"]" },
    { front: "How do you check if one string is a rotation of another?", back: "**Concatenation Trick: O(n) time**\n\n```\ndef isRotation(s1, s2):\n    if len(s1) != len(s2):\n        return False\n    \n    # The trick: s1+s1 contains all rotations of s1!\n    return s2 in (s1 + s1)\n```\n\n**Why it works:**\n- \"waterbottle\" + \"waterbottle\" = \"waterbottlewaterbottle\"\n- Contains all rotations: \"aterbottlew\", \"terbottlewa\", ... \"ewaterbottl\", \"waterbottle\"\n- If s2 is a rotation, it will appear as a substring\n\n**Example:**\n- s1 = \"waterbottle\", s2 = \"erbottlewat\"\n- s1 + s1 = \"waterbottle**erbottlewat**erbottle\"\n- s2 is found → True!\n\n**Alternative:** Find rotation point and verify character by character." },
    { front: "How do you implement Run-Length Encoding (string compression)?", back: "**Two-Pointer Approach: O(n) time**\n\n```\ndef compress(s):\n    if not s: return \"\"\n    \n    result = []\n    count = 1\n    \n    for i from 1 to len(s):\n        if i < len(s) and s[i] == s[i-1]:\n            count += 1\n        else:\n            result.append(s[i-1])\n            if count > 1:\n                result.append(str(count))\n            count = 1\n    \n    compressed = ''.join(result)\n    \n    # Return compressed only if it's shorter\n    return compressed if len(compressed) < len(s) else s\n```\n\n**Example:**\n- \"aabcccccaaa\" → \"a2b1c5a3\" (11 chars → 8 chars)\n- \"abcd\" → \"a1b1c1d1\" → Return original \"abcd\" (not shorter)" },
];
